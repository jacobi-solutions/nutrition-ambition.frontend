//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface INutritionAmbitionApiService {
    /**
     * @param body (optional) 
     * @return Success
     */
    registerAccount(body: RegisterAccountRequest | undefined): Observable<AccountResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getAccount(body: Request | undefined): Observable<AccountResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    changePassword(body: ChangePasswordRequest | undefined): Observable<Response>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getFeedbackWithAccountInfo(body: GetFeedbackWithAccountInfoRequest | undefined): Observable<GetFeedbackWithAccountInfoResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    completeFeedback(body: CompleteFeedbackRequest | undefined): Observable<CompleteFeedbackResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    deleteFeedback(body: DeleteFeedbackRequest | undefined): Observable<DeleteFeedbackResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getUserChatMessages(body: GetUserChatMessagesRequest | undefined): Observable<GetUserChatMessagesResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    searchLogs(body: SearchLogsRequest | undefined): Observable<SearchLogsResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getAllAccounts(body: GetAllAccountsRequest | undefined): Observable<GetAllAccountsResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    deleteAccount(body: DeleteAccountRequest | undefined): Observable<DeleteAccountResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    clearAccountData(body: ClearAccountDataRequest | undefined): Observable<ClearAccountDataResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getAccountDataCounts(body: GetAccountDataCountsRequest | undefined): Observable<GetAccountDataCountsResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    uploadGuidelineFile(body: UploadGuidelineFileRequest | undefined): Observable<UploadGuidelineFileResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getGuidelineFiles(body: GetGuidelineFilesRequest | undefined): Observable<GetGuidelineFilesResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    deleteGuidelineFile(body: DeleteGuidelineFileRequest | undefined): Observable<DeleteGuidelineFileResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getGuidelineFileUploadUrl(body: GetGuidelineFileUploadUrlRequest | undefined): Observable<GetGuidelineFileUploadUrlResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    confirmGuidelineFileUpload(body: ConfirmGuidelineFileUploadRequest | undefined): Observable<ConfirmGuidelineFileUploadResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getGuidelineFileViewUrl(body: GetGuidelineFileViewUrlRequest | undefined): Observable<GetGuidelineFileViewUrlResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getChatMessages(body: GetChatMessagesRequest | undefined): Observable<ChatMessagesResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    types(body: RunChatRequest | undefined): Observable<ChatMessagesResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    runResponsesConversation(body: RunChatRequest | undefined): Observable<void>;
    /**
     * @param body (optional) 
     * @return Success
     */
    types2(body: SetupGoalsRequest | undefined): Observable<ChatMessagesResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    setupGoals(body: SetupGoalsRequest | undefined): Observable<void>;
    /**
     * @param body (optional) 
     * @return Success
     */
    types3(body: LearnMoreAboutRequest | undefined): Observable<ChatMessagesResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    learnMoreAbout(body: LearnMoreAboutRequest | undefined): Observable<void>;
    /**
     * @return Success
     */
    deleteMessage(messageId: string): Observable<void>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getDetailedSummary(body: GetDetailedSummaryRequest | undefined): Observable<GetDetailedSummaryResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    add(body: AddFavoriteRequest | undefined): Observable<AddFavoriteResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    remove(body: RemoveFavoriteRequest | undefined): Observable<RemoveFavoriteResponse>;
    /**
     * @return Success
     */
    list(): Observable<GetFavoritesResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    relog(body: RelogFavoriteRequest | undefined): Observable<RelogFavoriteResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    deleteFoodEntry(body: DeleteFoodEntryRequest | undefined): Observable<DeleteFoodEntryResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    submitServingSelection(body: SubmitServingSelectionRequest | undefined): Observable<ChatMessagesResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    cancelFoodLogging(body: CancelServingSelectionRequest | undefined): Observable<ChatMessagesResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    startEditSelection(body: EditFoodSelectionRequest | undefined): Observable<ChatMessagesResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    submitEditServingSelection(body: SubmitEditServingSelectionRequest | undefined): Observable<ChatMessagesResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    cancelEditSelection(body: CancelEditSelectionRequest | undefined): Observable<ChatMessagesResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateFoodPhrase(body: SearchFoodPhraseRequest | undefined): Observable<SearchFoodPhraseResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    hydrateAlternateSelection(body: HydrateAlternateSelectionRequest | undefined): Observable<SearchFoodPhraseResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    searchFoodPhrase(body: SearchFoodPhraseRequest | undefined): Observable<SearchFoodPhraseResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getInstantAlternatives(body: GetInstantAlternativesRequest | undefined): Observable<GetInstantAlternativesResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateMealSelection(body: UpdateMealSelectionRequest | undefined): Observable<Response>;
    /**
     * @param body (optional) 
     * @return Success
     */
    directLogMealStream(body: DirectLogMealRequest | undefined): Observable<void>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getProfileAndTargets(body: GetProfileAndTargetsRequest | undefined): Observable<GetProfileAndTargetsResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    createSharedMeal(body: CreateSharedMealRequest | undefined): Observable<CreateSharedMealResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getSharedMeal(body: GetSharedMealRequest | undefined): Observable<GetSharedMealResponse>;
    /**
     * @return Success
     */
    ip(): Observable<void>;
}

@Injectable()
export class NutritionAmbitionApiService implements INutritionAmbitionApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    registerAccount(body: RegisterAccountRequest | undefined): Observable<AccountResponse> {
        let url_ = this.baseUrl + "/api/Accounts/RegisterAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountResponse>;
        }));
    }

    protected processRegisterAccount(response: HttpResponseBase): Observable<AccountResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccountResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAccount(body: Request | undefined): Observable<AccountResponse> {
        let url_ = this.baseUrl + "/api/Accounts/GetAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountResponse>;
        }));
    }

    protected processGetAccount(response: HttpResponseBase): Observable<AccountResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccountResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePassword(body: ChangePasswordRequest | undefined): Observable<Response> {
        let url_ = this.baseUrl + "/api/Accounts/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Response>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Response>;
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Response.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getFeedbackWithAccountInfo(body: GetFeedbackWithAccountInfoRequest | undefined): Observable<GetFeedbackWithAccountInfoResponse> {
        let url_ = this.baseUrl + "/api/Admin/GetFeedbackWithAccountInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFeedbackWithAccountInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFeedbackWithAccountInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetFeedbackWithAccountInfoResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetFeedbackWithAccountInfoResponse>;
        }));
    }

    protected processGetFeedbackWithAccountInfo(response: HttpResponseBase): Observable<GetFeedbackWithAccountInfoResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetFeedbackWithAccountInfoResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetFeedbackWithAccountInfoResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    completeFeedback(body: CompleteFeedbackRequest | undefined): Observable<CompleteFeedbackResponse> {
        let url_ = this.baseUrl + "/api/Admin/CompleteFeedback";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompleteFeedback(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompleteFeedback(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompleteFeedbackResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompleteFeedbackResponse>;
        }));
    }

    protected processCompleteFeedback(response: HttpResponseBase): Observable<CompleteFeedbackResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompleteFeedbackResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompleteFeedbackResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteFeedback(body: DeleteFeedbackRequest | undefined): Observable<DeleteFeedbackResponse> {
        let url_ = this.baseUrl + "/api/Admin/DeleteFeedback";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteFeedback(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteFeedback(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DeleteFeedbackResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DeleteFeedbackResponse>;
        }));
    }

    protected processDeleteFeedback(response: HttpResponseBase): Observable<DeleteFeedbackResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeleteFeedbackResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeleteFeedbackResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getUserChatMessages(body: GetUserChatMessagesRequest | undefined): Observable<GetUserChatMessagesResponse> {
        let url_ = this.baseUrl + "/api/Admin/GetUserChatMessages";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserChatMessages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserChatMessages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetUserChatMessagesResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetUserChatMessagesResponse>;
        }));
    }

    protected processGetUserChatMessages(response: HttpResponseBase): Observable<GetUserChatMessagesResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserChatMessagesResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserChatMessagesResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchLogs(body: SearchLogsRequest | undefined): Observable<SearchLogsResponse> {
        let url_ = this.baseUrl + "/api/Admin/SearchLogs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SearchLogsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SearchLogsResponse>;
        }));
    }

    protected processSearchLogs(response: HttpResponseBase): Observable<SearchLogsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchLogsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SearchLogsResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAllAccounts(body: GetAllAccountsRequest | undefined): Observable<GetAllAccountsResponse> {
        let url_ = this.baseUrl + "/api/Admin/GetAllAccounts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAccounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAccounts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllAccountsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllAccountsResponse>;
        }));
    }

    protected processGetAllAccounts(response: HttpResponseBase): Observable<GetAllAccountsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAllAccountsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAllAccountsResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteAccount(body: DeleteAccountRequest | undefined): Observable<DeleteAccountResponse> {
        let url_ = this.baseUrl + "/api/Admin/DeleteAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DeleteAccountResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DeleteAccountResponse>;
        }));
    }

    protected processDeleteAccount(response: HttpResponseBase): Observable<DeleteAccountResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeleteAccountResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeleteAccountResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    clearAccountData(body: ClearAccountDataRequest | undefined): Observable<ClearAccountDataResponse> {
        let url_ = this.baseUrl + "/api/Admin/ClearAccountData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearAccountData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearAccountData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClearAccountDataResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClearAccountDataResponse>;
        }));
    }

    protected processClearAccountData(response: HttpResponseBase): Observable<ClearAccountDataResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClearAccountDataResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClearAccountDataResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAccountDataCounts(body: GetAccountDataCountsRequest | undefined): Observable<GetAccountDataCountsResponse> {
        let url_ = this.baseUrl + "/api/Admin/GetAccountDataCounts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccountDataCounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccountDataCounts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAccountDataCountsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAccountDataCountsResponse>;
        }));
    }

    protected processGetAccountDataCounts(response: HttpResponseBase): Observable<GetAccountDataCountsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAccountDataCountsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAccountDataCountsResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    uploadGuidelineFile(body: UploadGuidelineFileRequest | undefined): Observable<UploadGuidelineFileResponse> {
        let url_ = this.baseUrl + "/api/Admin/UploadGuidelineFile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadGuidelineFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadGuidelineFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UploadGuidelineFileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UploadGuidelineFileResponse>;
        }));
    }

    protected processUploadGuidelineFile(response: HttpResponseBase): Observable<UploadGuidelineFileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UploadGuidelineFileResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UploadGuidelineFileResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getGuidelineFiles(body: GetGuidelineFilesRequest | undefined): Observable<GetGuidelineFilesResponse> {
        let url_ = this.baseUrl + "/api/Admin/GetGuidelineFiles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGuidelineFiles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGuidelineFiles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetGuidelineFilesResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetGuidelineFilesResponse>;
        }));
    }

    protected processGetGuidelineFiles(response: HttpResponseBase): Observable<GetGuidelineFilesResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetGuidelineFilesResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetGuidelineFilesResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteGuidelineFile(body: DeleteGuidelineFileRequest | undefined): Observable<DeleteGuidelineFileResponse> {
        let url_ = this.baseUrl + "/api/Admin/DeleteGuidelineFile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteGuidelineFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteGuidelineFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DeleteGuidelineFileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DeleteGuidelineFileResponse>;
        }));
    }

    protected processDeleteGuidelineFile(response: HttpResponseBase): Observable<DeleteGuidelineFileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeleteGuidelineFileResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeleteGuidelineFileResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getGuidelineFileUploadUrl(body: GetGuidelineFileUploadUrlRequest | undefined): Observable<GetGuidelineFileUploadUrlResponse> {
        let url_ = this.baseUrl + "/api/Admin/GetGuidelineFileUploadUrl";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGuidelineFileUploadUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGuidelineFileUploadUrl(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetGuidelineFileUploadUrlResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetGuidelineFileUploadUrlResponse>;
        }));
    }

    protected processGetGuidelineFileUploadUrl(response: HttpResponseBase): Observable<GetGuidelineFileUploadUrlResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetGuidelineFileUploadUrlResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetGuidelineFileUploadUrlResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    confirmGuidelineFileUpload(body: ConfirmGuidelineFileUploadRequest | undefined): Observable<ConfirmGuidelineFileUploadResponse> {
        let url_ = this.baseUrl + "/api/Admin/ConfirmGuidelineFileUpload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmGuidelineFileUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmGuidelineFileUpload(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConfirmGuidelineFileUploadResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConfirmGuidelineFileUploadResponse>;
        }));
    }

    protected processConfirmGuidelineFileUpload(response: HttpResponseBase): Observable<ConfirmGuidelineFileUploadResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConfirmGuidelineFileUploadResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConfirmGuidelineFileUploadResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getGuidelineFileViewUrl(body: GetGuidelineFileViewUrlRequest | undefined): Observable<GetGuidelineFileViewUrlResponse> {
        let url_ = this.baseUrl + "/api/Admin/GetGuidelineFileViewUrl";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGuidelineFileViewUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGuidelineFileViewUrl(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetGuidelineFileViewUrlResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetGuidelineFileViewUrlResponse>;
        }));
    }

    protected processGetGuidelineFileViewUrl(response: HttpResponseBase): Observable<GetGuidelineFileViewUrlResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetGuidelineFileViewUrlResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetGuidelineFileViewUrlResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getChatMessages(body: GetChatMessagesRequest | undefined): Observable<ChatMessagesResponse> {
        let url_ = this.baseUrl + "/api/Conversation/GetChatMessages";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetChatMessages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChatMessages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChatMessagesResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChatMessagesResponse>;
        }));
    }

    protected processGetChatMessages(response: HttpResponseBase): Observable<ChatMessagesResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChatMessagesResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChatMessagesResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    types(body: RunChatRequest | undefined): Observable<ChatMessagesResponse> {
        let url_ = this.baseUrl + "/api/Conversation/RunResponsesConversation/types";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChatMessagesResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChatMessagesResponse>;
        }));
    }

    protected processTypes(response: HttpResponseBase): Observable<ChatMessagesResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChatMessagesResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChatMessagesResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    runResponsesConversation(body: RunChatRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Conversation/RunResponsesConversation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRunResponsesConversation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRunResponsesConversation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRunResponsesConversation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    types2(body: SetupGoalsRequest | undefined): Observable<ChatMessagesResponse> {
        let url_ = this.baseUrl + "/api/Conversation/SetupGoals/types";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTypes2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTypes2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChatMessagesResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChatMessagesResponse>;
        }));
    }

    protected processTypes2(response: HttpResponseBase): Observable<ChatMessagesResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChatMessagesResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChatMessagesResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setupGoals(body: SetupGoalsRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Conversation/SetupGoals";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetupGoals(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetupGoals(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetupGoals(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    types3(body: LearnMoreAboutRequest | undefined): Observable<ChatMessagesResponse> {
        let url_ = this.baseUrl + "/api/Conversation/LearnMoreAbout/types";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTypes3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTypes3(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChatMessagesResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChatMessagesResponse>;
        }));
    }

    protected processTypes3(response: HttpResponseBase): Observable<ChatMessagesResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChatMessagesResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChatMessagesResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    learnMoreAbout(body: LearnMoreAboutRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Conversation/LearnMoreAbout";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLearnMoreAbout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLearnMoreAbout(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processLearnMoreAbout(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    deleteMessage(messageId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Conversation/DeleteMessage/{messageId}";
        if (messageId === undefined || messageId === null)
            throw new Error("The parameter 'messageId' must be defined.");
        url_ = url_.replace("{messageId}", encodeURIComponent("" + messageId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMessage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMessage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteMessage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getDetailedSummary(body: GetDetailedSummaryRequest | undefined): Observable<GetDetailedSummaryResponse> {
        let url_ = this.baseUrl + "/api/DetailedSummary/GetDetailedSummary";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetailedSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetailedSummary(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetDetailedSummaryResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetDetailedSummaryResponse>;
        }));
    }

    protected processGetDetailedSummary(response: HttpResponseBase): Observable<GetDetailedSummaryResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetDetailedSummaryResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDetailedSummaryResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    add(body: AddFavoriteRequest | undefined): Observable<AddFavoriteResponse> {
        let url_ = this.baseUrl + "/api/Favorites/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AddFavoriteResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AddFavoriteResponse>;
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<AddFavoriteResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AddFavoriteResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AddFavoriteResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    remove(body: RemoveFavoriteRequest | undefined): Observable<RemoveFavoriteResponse> {
        let url_ = this.baseUrl + "/api/Favorites/Remove";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemove(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemove(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RemoveFavoriteResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RemoveFavoriteResponse>;
        }));
    }

    protected processRemove(response: HttpResponseBase): Observable<RemoveFavoriteResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RemoveFavoriteResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RemoveFavoriteResponse>(null as any);
    }

    /**
     * @return Success
     */
    list(): Observable<GetFavoritesResponse> {
        let url_ = this.baseUrl + "/api/Favorites/List";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetFavoritesResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetFavoritesResponse>;
        }));
    }

    protected processList(response: HttpResponseBase): Observable<GetFavoritesResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetFavoritesResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetFavoritesResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    relog(body: RelogFavoriteRequest | undefined): Observable<RelogFavoriteResponse> {
        let url_ = this.baseUrl + "/api/Favorites/Relog";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRelog(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRelog(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RelogFavoriteResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RelogFavoriteResponse>;
        }));
    }

    protected processRelog(response: HttpResponseBase): Observable<RelogFavoriteResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RelogFavoriteResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RelogFavoriteResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteFoodEntry(body: DeleteFoodEntryRequest | undefined): Observable<DeleteFoodEntryResponse> {
        let url_ = this.baseUrl + "/api/FoodEntry/DeleteFoodEntry";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteFoodEntry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteFoodEntry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DeleteFoodEntryResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DeleteFoodEntryResponse>;
        }));
    }

    protected processDeleteFoodEntry(response: HttpResponseBase): Observable<DeleteFoodEntryResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeleteFoodEntryResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeleteFoodEntryResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    submitServingSelection(body: SubmitServingSelectionRequest | undefined): Observable<ChatMessagesResponse> {
        let url_ = this.baseUrl + "/api/FoodSelection/SubmitServingSelection";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmitServingSelection(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitServingSelection(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChatMessagesResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChatMessagesResponse>;
        }));
    }

    protected processSubmitServingSelection(response: HttpResponseBase): Observable<ChatMessagesResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChatMessagesResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChatMessagesResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cancelFoodLogging(body: CancelServingSelectionRequest | undefined): Observable<ChatMessagesResponse> {
        let url_ = this.baseUrl + "/api/FoodSelection/CancelFoodLogging";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelFoodLogging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelFoodLogging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChatMessagesResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChatMessagesResponse>;
        }));
    }

    protected processCancelFoodLogging(response: HttpResponseBase): Observable<ChatMessagesResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChatMessagesResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChatMessagesResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    startEditSelection(body: EditFoodSelectionRequest | undefined): Observable<ChatMessagesResponse> {
        let url_ = this.baseUrl + "/api/FoodSelection/StartEditSelection";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStartEditSelection(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStartEditSelection(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChatMessagesResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChatMessagesResponse>;
        }));
    }

    protected processStartEditSelection(response: HttpResponseBase): Observable<ChatMessagesResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChatMessagesResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChatMessagesResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    submitEditServingSelection(body: SubmitEditServingSelectionRequest | undefined): Observable<ChatMessagesResponse> {
        let url_ = this.baseUrl + "/api/FoodSelection/SubmitEditServingSelection";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmitEditServingSelection(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitEditServingSelection(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChatMessagesResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChatMessagesResponse>;
        }));
    }

    protected processSubmitEditServingSelection(response: HttpResponseBase): Observable<ChatMessagesResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChatMessagesResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChatMessagesResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cancelEditSelection(body: CancelEditSelectionRequest | undefined): Observable<ChatMessagesResponse> {
        let url_ = this.baseUrl + "/api/FoodSelection/CancelEditSelection";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelEditSelection(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelEditSelection(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChatMessagesResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChatMessagesResponse>;
        }));
    }

    protected processCancelEditSelection(response: HttpResponseBase): Observable<ChatMessagesResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChatMessagesResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChatMessagesResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateFoodPhrase(body: SearchFoodPhraseRequest | undefined): Observable<SearchFoodPhraseResponse> {
        let url_ = this.baseUrl + "/api/FoodSelection/UpdateFoodPhrase";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateFoodPhrase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateFoodPhrase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SearchFoodPhraseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SearchFoodPhraseResponse>;
        }));
    }

    protected processUpdateFoodPhrase(response: HttpResponseBase): Observable<SearchFoodPhraseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchFoodPhraseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SearchFoodPhraseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    hydrateAlternateSelection(body: HydrateAlternateSelectionRequest | undefined): Observable<SearchFoodPhraseResponse> {
        let url_ = this.baseUrl + "/api/FoodSelection/HydrateAlternateSelection";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHydrateAlternateSelection(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHydrateAlternateSelection(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SearchFoodPhraseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SearchFoodPhraseResponse>;
        }));
    }

    protected processHydrateAlternateSelection(response: HttpResponseBase): Observable<SearchFoodPhraseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchFoodPhraseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SearchFoodPhraseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchFoodPhrase(body: SearchFoodPhraseRequest | undefined): Observable<SearchFoodPhraseResponse> {
        let url_ = this.baseUrl + "/api/FoodSelection/SearchFoodPhrase";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchFoodPhrase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchFoodPhrase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SearchFoodPhraseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SearchFoodPhraseResponse>;
        }));
    }

    protected processSearchFoodPhrase(response: HttpResponseBase): Observable<SearchFoodPhraseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchFoodPhraseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SearchFoodPhraseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getInstantAlternatives(body: GetInstantAlternativesRequest | undefined): Observable<GetInstantAlternativesResponse> {
        let url_ = this.baseUrl + "/api/FoodSelection/GetInstantAlternatives";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInstantAlternatives(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInstantAlternatives(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetInstantAlternativesResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetInstantAlternativesResponse>;
        }));
    }

    protected processGetInstantAlternatives(response: HttpResponseBase): Observable<GetInstantAlternativesResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetInstantAlternativesResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetInstantAlternativesResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateMealSelection(body: UpdateMealSelectionRequest | undefined): Observable<Response> {
        let url_ = this.baseUrl + "/api/FoodSelection/UpdateMealSelection";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMealSelection(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMealSelection(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Response>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Response>;
        }));
    }

    protected processUpdateMealSelection(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Response.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    directLogMealStream(body: DirectLogMealRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/FoodSelection/DirectLogMealStream";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDirectLogMealStream(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDirectLogMealStream(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDirectLogMealStream(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getProfileAndTargets(body: GetProfileAndTargetsRequest | undefined): Observable<GetProfileAndTargetsResponse> {
        let url_ = this.baseUrl + "/api/Profile/GetProfileAndTargets";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfileAndTargets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfileAndTargets(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetProfileAndTargetsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetProfileAndTargetsResponse>;
        }));
    }

    protected processGetProfileAndTargets(response: HttpResponseBase): Observable<GetProfileAndTargetsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProfileAndTargetsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfileAndTargetsResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createSharedMeal(body: CreateSharedMealRequest | undefined): Observable<CreateSharedMealResponse> {
        let url_ = this.baseUrl + "/api/SharedMeal/CreateSharedMeal";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSharedMeal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSharedMeal(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateSharedMealResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateSharedMealResponse>;
        }));
    }

    protected processCreateSharedMeal(response: HttpResponseBase): Observable<CreateSharedMealResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateSharedMealResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateSharedMealResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getSharedMeal(body: GetSharedMealRequest | undefined): Observable<GetSharedMealResponse> {
        let url_ = this.baseUrl + "/api/SharedMeal/GetSharedMeal";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSharedMeal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSharedMeal(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSharedMealResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSharedMealResponse>;
        }));
    }

    protected processGetSharedMeal(response: HttpResponseBase): Observable<GetSharedMealResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSharedMealResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSharedMealResponse>(null as any);
    }

    /**
     * @return Success
     */
    ip(): Observable<void> {
        let url_ = this.baseUrl + "/api/Test/ip";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processIp(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

export class Account implements IAccount {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    name?: string | undefined;
    email?: string | undefined;
    timeZoneId?: string | undefined;
    isOwner?: boolean;
    hasUnacknowledgedFeedbackResponses?: boolean;
    canDelete?: boolean;
    canClear?: boolean;

    constructor(data?: IAccount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdDateUtc = _data["createdDateUtc"] ? new Date(_data["createdDateUtc"].toString()) : <any>undefined;
            this.lastUpdatedDateUtc = _data["lastUpdatedDateUtc"] ? new Date(_data["lastUpdatedDateUtc"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.email = _data["email"];
            this.timeZoneId = _data["timeZoneId"];
            this.isOwner = _data["isOwner"];
            this.hasUnacknowledgedFeedbackResponses = _data["hasUnacknowledgedFeedbackResponses"];
            this.canDelete = _data["canDelete"];
            this.canClear = _data["canClear"];
        }
    }

    static fromJS(data: any): Account {
        data = typeof data === 'object' ? data : {};
        let result = new Account();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdDateUtc"] = this.createdDateUtc ? this.createdDateUtc.toISOString() : <any>undefined;
        data["lastUpdatedDateUtc"] = this.lastUpdatedDateUtc ? this.lastUpdatedDateUtc.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["email"] = this.email;
        data["timeZoneId"] = this.timeZoneId;
        data["isOwner"] = this.isOwner;
        data["hasUnacknowledgedFeedbackResponses"] = this.hasUnacknowledgedFeedbackResponses;
        data["canDelete"] = this.canDelete;
        data["canClear"] = this.canClear;
        return data;
    }
}

export interface IAccount {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    name?: string | undefined;
    email?: string | undefined;
    timeZoneId?: string | undefined;
    isOwner?: boolean;
    hasUnacknowledgedFeedbackResponses?: boolean;
    canDelete?: boolean;
    canClear?: boolean;
}

export class AccountResponse implements IAccountResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;
    account?: Account;

    constructor(data?: IAccountResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.correlationId = _data["correlationId"];
            this.stackTrace = _data["stackTrace"];
            this.accountId = _data["accountId"];
            this.isPartial = _data["isPartial"];
            this.processingStage = _data["processingStage"];
            this.messageId = _data["messageId"];
            this.account = _data["account"] ? Account.fromJS(_data["account"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AccountResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AccountResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["correlationId"] = this.correlationId;
        data["stackTrace"] = this.stackTrace;
        data["accountId"] = this.accountId;
        data["isPartial"] = this.isPartial;
        data["processingStage"] = this.processingStage;
        data["messageId"] = this.messageId;
        data["account"] = this.account ? this.account.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAccountResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;
    account?: Account;
}

export class AddFavoriteRequest implements IAddFavoriteRequest {
    foodEntryId!: string;
    foodId!: string;
    customLabel?: string | undefined;

    constructor(data?: IAddFavoriteRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.foodEntryId = _data["foodEntryId"];
            this.foodId = _data["foodId"];
            this.customLabel = _data["customLabel"];
        }
    }

    static fromJS(data: any): AddFavoriteRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddFavoriteRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["foodEntryId"] = this.foodEntryId;
        data["foodId"] = this.foodId;
        data["customLabel"] = this.customLabel;
        return data;
    }
}

export interface IAddFavoriteRequest {
    foodEntryId: string;
    foodId: string;
    customLabel?: string | undefined;
}

export class AddFavoriteResponse implements IAddFavoriteResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;
    favorite?: FavoriteFoodDto;

    constructor(data?: IAddFavoriteResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.correlationId = _data["correlationId"];
            this.stackTrace = _data["stackTrace"];
            this.accountId = _data["accountId"];
            this.isPartial = _data["isPartial"];
            this.processingStage = _data["processingStage"];
            this.messageId = _data["messageId"];
            this.favorite = _data["favorite"] ? FavoriteFoodDto.fromJS(_data["favorite"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AddFavoriteResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AddFavoriteResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["correlationId"] = this.correlationId;
        data["stackTrace"] = this.stackTrace;
        data["accountId"] = this.accountId;
        data["isPartial"] = this.isPartial;
        data["processingStage"] = this.processingStage;
        data["messageId"] = this.messageId;
        data["favorite"] = this.favorite ? this.favorite.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAddFavoriteResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;
    favorite?: FavoriteFoodDto;
}

export enum AssistantModeTypes {
    Default = "Default",
    GoalSetting = "GoalSetting",
    UserFeedback = "UserFeedback",
}

export class BuildStamp implements IBuildStamp {
    appVersion?: string | undefined;
    previousCommitHash?: string | undefined;

    constructor(data?: IBuildStamp) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appVersion = _data["appVersion"];
            this.previousCommitHash = _data["previousCommitHash"];
        }
    }

    static fromJS(data: any): BuildStamp {
        data = typeof data === 'object' ? data : {};
        let result = new BuildStamp();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appVersion"] = this.appVersion;
        data["previousCommitHash"] = this.previousCommitHash;
        return data;
    }
}

export interface IBuildStamp {
    appVersion?: string | undefined;
    previousCommitHash?: string | undefined;
}

export class CancelEditSelectionRequest implements ICancelEditSelectionRequest {
    pendingMessageId?: string | undefined;
    localDateKey?: string | undefined;

    constructor(data?: ICancelEditSelectionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pendingMessageId = _data["pendingMessageId"];
            this.localDateKey = _data["localDateKey"];
        }
    }

    static fromJS(data: any): CancelEditSelectionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CancelEditSelectionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pendingMessageId"] = this.pendingMessageId;
        data["localDateKey"] = this.localDateKey;
        return data;
    }
}

export interface ICancelEditSelectionRequest {
    pendingMessageId?: string | undefined;
    localDateKey?: string | undefined;
}

export class CancelServingSelectionRequest implements ICancelServingSelectionRequest {
    pendingMessageId?: string | undefined;
    localDateKey?: string | undefined;

    constructor(data?: ICancelServingSelectionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pendingMessageId = _data["pendingMessageId"];
            this.localDateKey = _data["localDateKey"];
        }
    }

    static fromJS(data: any): CancelServingSelectionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CancelServingSelectionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pendingMessageId"] = this.pendingMessageId;
        data["localDateKey"] = this.localDateKey;
        return data;
    }
}

export interface ICancelServingSelectionRequest {
    pendingMessageId?: string | undefined;
    localDateKey?: string | undefined;
}

export class ChangePasswordRequest implements IChangePasswordRequest {
    newPassword?: string | undefined;

    constructor(data?: IChangePasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IChangePasswordRequest {
    newPassword?: string | undefined;
}

export class ChatMessage implements IChatMessage {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    accountId?: string | undefined;
    role?: MessageRoleTypes;
    content?: string | undefined;
    localDateKey?: string | undefined;
    foodEntryIds?: string[] | undefined;
    isRead?: boolean;
    toolCallId?: string | undefined;
    toolFunctionName?: string | undefined;
    toolCallArgumentsJson?: string | undefined;
    responseId?: string | undefined;
    assistantMode?: AssistantModeTypes;
    assistantPhase?: string | undefined;
    mealSelections?: MealSelection[] | undefined;
    retryCount?: number;
    modelUsed?: string | undefined;
    promptTokens?: number | undefined;
    completionTokens?: number | undefined;
    totalTokens?: number | undefined;

    constructor(data?: IChatMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdDateUtc = _data["createdDateUtc"] ? new Date(_data["createdDateUtc"].toString()) : <any>undefined;
            this.lastUpdatedDateUtc = _data["lastUpdatedDateUtc"] ? new Date(_data["lastUpdatedDateUtc"].toString()) : <any>undefined;
            this.accountId = _data["accountId"];
            this.role = _data["role"];
            this.content = _data["content"];
            this.localDateKey = _data["localDateKey"];
            if (Array.isArray(_data["foodEntryIds"])) {
                this.foodEntryIds = [] as any;
                for (let item of _data["foodEntryIds"])
                    this.foodEntryIds!.push(item);
            }
            this.isRead = _data["isRead"];
            this.toolCallId = _data["toolCallId"];
            this.toolFunctionName = _data["toolFunctionName"];
            this.toolCallArgumentsJson = _data["toolCallArgumentsJson"];
            this.responseId = _data["responseId"];
            this.assistantMode = _data["assistantMode"];
            this.assistantPhase = _data["assistantPhase"];
            if (Array.isArray(_data["mealSelections"])) {
                this.mealSelections = [] as any;
                for (let item of _data["mealSelections"])
                    this.mealSelections!.push(MealSelection.fromJS(item));
            }
            this.retryCount = _data["retryCount"];
            this.modelUsed = _data["modelUsed"];
            this.promptTokens = _data["promptTokens"];
            this.completionTokens = _data["completionTokens"];
            this.totalTokens = _data["totalTokens"];
        }
    }

    static fromJS(data: any): ChatMessage {
        data = typeof data === 'object' ? data : {};
        let result = new ChatMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdDateUtc"] = this.createdDateUtc ? this.createdDateUtc.toISOString() : <any>undefined;
        data["lastUpdatedDateUtc"] = this.lastUpdatedDateUtc ? this.lastUpdatedDateUtc.toISOString() : <any>undefined;
        data["accountId"] = this.accountId;
        data["role"] = this.role;
        data["content"] = this.content;
        data["localDateKey"] = this.localDateKey;
        if (Array.isArray(this.foodEntryIds)) {
            data["foodEntryIds"] = [];
            for (let item of this.foodEntryIds)
                data["foodEntryIds"].push(item);
        }
        data["isRead"] = this.isRead;
        data["toolCallId"] = this.toolCallId;
        data["toolFunctionName"] = this.toolFunctionName;
        data["toolCallArgumentsJson"] = this.toolCallArgumentsJson;
        data["responseId"] = this.responseId;
        data["assistantMode"] = this.assistantMode;
        data["assistantPhase"] = this.assistantPhase;
        if (Array.isArray(this.mealSelections)) {
            data["mealSelections"] = [];
            for (let item of this.mealSelections)
                data["mealSelections"].push(item.toJSON());
        }
        data["retryCount"] = this.retryCount;
        data["modelUsed"] = this.modelUsed;
        data["promptTokens"] = this.promptTokens;
        data["completionTokens"] = this.completionTokens;
        data["totalTokens"] = this.totalTokens;
        return data;
    }
}

export interface IChatMessage {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    accountId?: string | undefined;
    role?: MessageRoleTypes;
    content?: string | undefined;
    localDateKey?: string | undefined;
    foodEntryIds?: string[] | undefined;
    isRead?: boolean;
    toolCallId?: string | undefined;
    toolFunctionName?: string | undefined;
    toolCallArgumentsJson?: string | undefined;
    responseId?: string | undefined;
    assistantMode?: AssistantModeTypes;
    assistantPhase?: string | undefined;
    mealSelections?: MealSelection[] | undefined;
    retryCount?: number;
    modelUsed?: string | undefined;
    promptTokens?: number | undefined;
    completionTokens?: number | undefined;
    totalTokens?: number | undefined;
}

export class ChatMessagesResponse implements IChatMessagesResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;
    messages?: ChatMessage[] | undefined;

    constructor(data?: IChatMessagesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.correlationId = _data["correlationId"];
            this.stackTrace = _data["stackTrace"];
            this.accountId = _data["accountId"];
            this.isPartial = _data["isPartial"];
            this.processingStage = _data["processingStage"];
            this.messageId = _data["messageId"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ChatMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ChatMessagesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ChatMessagesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["correlationId"] = this.correlationId;
        data["stackTrace"] = this.stackTrace;
        data["accountId"] = this.accountId;
        data["isPartial"] = this.isPartial;
        data["processingStage"] = this.processingStage;
        data["messageId"] = this.messageId;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IChatMessagesResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;
    messages?: ChatMessage[] | undefined;
}

export class ClearAccountDataRequest implements IClearAccountDataRequest {
    accountId?: string | undefined;
    confirmClear?: boolean;

    constructor(data?: IClearAccountDataRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountId = _data["accountId"];
            this.confirmClear = _data["confirmClear"];
        }
    }

    static fromJS(data: any): ClearAccountDataRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ClearAccountDataRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountId"] = this.accountId;
        data["confirmClear"] = this.confirmClear;
        return data;
    }
}

export interface IClearAccountDataRequest {
    accountId?: string | undefined;
    confirmClear?: boolean;
}

export class ClearAccountDataResponse implements IClearAccountDataResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;
    dataCleared?: boolean;
    clearedAccountId?: string | undefined;
    totalRecordsDeleted?: number;
    deletedRecordsByType?: { [key: string]: number; } | undefined;

    constructor(data?: IClearAccountDataResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.correlationId = _data["correlationId"];
            this.stackTrace = _data["stackTrace"];
            this.accountId = _data["accountId"];
            this.isPartial = _data["isPartial"];
            this.processingStage = _data["processingStage"];
            this.messageId = _data["messageId"];
            this.dataCleared = _data["dataCleared"];
            this.clearedAccountId = _data["clearedAccountId"];
            this.totalRecordsDeleted = _data["totalRecordsDeleted"];
            if (_data["deletedRecordsByType"]) {
                this.deletedRecordsByType = {} as any;
                for (let key in _data["deletedRecordsByType"]) {
                    if (_data["deletedRecordsByType"].hasOwnProperty(key))
                        (<any>this.deletedRecordsByType)![key] = _data["deletedRecordsByType"][key];
                }
            }
        }
    }

    static fromJS(data: any): ClearAccountDataResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ClearAccountDataResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["correlationId"] = this.correlationId;
        data["stackTrace"] = this.stackTrace;
        data["accountId"] = this.accountId;
        data["isPartial"] = this.isPartial;
        data["processingStage"] = this.processingStage;
        data["messageId"] = this.messageId;
        data["dataCleared"] = this.dataCleared;
        data["clearedAccountId"] = this.clearedAccountId;
        data["totalRecordsDeleted"] = this.totalRecordsDeleted;
        if (this.deletedRecordsByType) {
            data["deletedRecordsByType"] = {};
            for (let key in this.deletedRecordsByType) {
                if (this.deletedRecordsByType.hasOwnProperty(key))
                    (<any>data["deletedRecordsByType"])[key] = (<any>this.deletedRecordsByType)[key];
            }
        }
        return data;
    }
}

export interface IClearAccountDataResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;
    dataCleared?: boolean;
    clearedAccountId?: string | undefined;
    totalRecordsDeleted?: number;
    deletedRecordsByType?: { [key: string]: number; } | undefined;
}

export class CompleteFeedbackRequest implements ICompleteFeedbackRequest {
    feedbackId?: string | undefined;
    completionNote!: string;
    isCompleted?: boolean;

    constructor(data?: ICompleteFeedbackRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.feedbackId = _data["feedbackId"];
            this.completionNote = _data["completionNote"];
            this.isCompleted = _data["isCompleted"];
        }
    }

    static fromJS(data: any): CompleteFeedbackRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CompleteFeedbackRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["feedbackId"] = this.feedbackId;
        data["completionNote"] = this.completionNote;
        data["isCompleted"] = this.isCompleted;
        return data;
    }
}

export interface ICompleteFeedbackRequest {
    feedbackId?: string | undefined;
    completionNote: string;
    isCompleted?: boolean;
}

export class CompleteFeedbackResponse implements ICompleteFeedbackResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;
    feedbackEntry?: FeedbackEntry;

    constructor(data?: ICompleteFeedbackResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.correlationId = _data["correlationId"];
            this.stackTrace = _data["stackTrace"];
            this.accountId = _data["accountId"];
            this.isPartial = _data["isPartial"];
            this.processingStage = _data["processingStage"];
            this.messageId = _data["messageId"];
            this.feedbackEntry = _data["feedbackEntry"] ? FeedbackEntry.fromJS(_data["feedbackEntry"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CompleteFeedbackResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CompleteFeedbackResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["correlationId"] = this.correlationId;
        data["stackTrace"] = this.stackTrace;
        data["accountId"] = this.accountId;
        data["isPartial"] = this.isPartial;
        data["processingStage"] = this.processingStage;
        data["messageId"] = this.messageId;
        data["feedbackEntry"] = this.feedbackEntry ? this.feedbackEntry.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICompleteFeedbackResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;
    feedbackEntry?: FeedbackEntry;
}

export class Component implements IComponent {
    id?: string | undefined;
    selectedComponentId?: string | undefined;
    matches?: ComponentMatch[] | undefined;
    culinaryRole?: string | undefined;
    isPending?: boolean;
    statusText?: string | undefined;

    constructor(data?: IComponent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.selectedComponentId = _data["selectedComponentId"];
            if (Array.isArray(_data["matches"])) {
                this.matches = [] as any;
                for (let item of _data["matches"])
                    this.matches!.push(ComponentMatch.fromJS(item));
            }
            this.culinaryRole = _data["culinaryRole"];
            this.isPending = _data["isPending"];
            this.statusText = _data["statusText"];
        }
    }

    static fromJS(data: any): Component {
        data = typeof data === 'object' ? data : {};
        let result = new Component();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["selectedComponentId"] = this.selectedComponentId;
        if (Array.isArray(this.matches)) {
            data["matches"] = [];
            for (let item of this.matches)
                data["matches"].push(item.toJSON());
        }
        data["culinaryRole"] = this.culinaryRole;
        data["isPending"] = this.isPending;
        data["statusText"] = this.statusText;
        return data;
    }
}

export interface IComponent {
    id?: string | undefined;
    selectedComponentId?: string | undefined;
    matches?: ComponentMatch[] | undefined;
    culinaryRole?: string | undefined;
    isPending?: boolean;
    statusText?: string | undefined;
}

export class ComponentBreakdown implements IComponentBreakdown {
    componentId?: string | undefined;
    componentKey?: string | undefined;
    name?: string | undefined;
    brandName?: string | undefined;
    totalAmount?: number;
    unit?: string | undefined;
    inferred?: boolean;
    nutrients?: NutrientContribution[] | undefined;

    constructor(data?: IComponentBreakdown) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.componentId = _data["componentId"];
            this.componentKey = _data["componentKey"];
            this.name = _data["name"];
            this.brandName = _data["brandName"];
            this.totalAmount = _data["totalAmount"];
            this.unit = _data["unit"];
            this.inferred = _data["inferred"];
            if (Array.isArray(_data["nutrients"])) {
                this.nutrients = [] as any;
                for (let item of _data["nutrients"])
                    this.nutrients!.push(NutrientContribution.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ComponentBreakdown {
        data = typeof data === 'object' ? data : {};
        let result = new ComponentBreakdown();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["componentId"] = this.componentId;
        data["componentKey"] = this.componentKey;
        data["name"] = this.name;
        data["brandName"] = this.brandName;
        data["totalAmount"] = this.totalAmount;
        data["unit"] = this.unit;
        data["inferred"] = this.inferred;
        if (Array.isArray(this.nutrients)) {
            data["nutrients"] = [];
            for (let item of this.nutrients)
                data["nutrients"].push(item.toJSON());
        }
        return data;
    }
}

export interface IComponentBreakdown {
    componentId?: string | undefined;
    componentKey?: string | undefined;
    name?: string | undefined;
    brandName?: string | undefined;
    totalAmount?: number;
    unit?: string | undefined;
    inferred?: boolean;
    nutrients?: NutrientContribution[] | undefined;
}

export class ComponentDescription implements IComponentDescription {
    id?: string | undefined;
    name?: string | undefined;
    quantity?: number | undefined;
    singularUnit?: string | undefined;
    pluralUnit?: string | undefined;
    culinaryRole?: string | undefined;

    constructor(data?: IComponentDescription) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.quantity = _data["quantity"];
            this.singularUnit = _data["singularUnit"];
            this.pluralUnit = _data["pluralUnit"];
            this.culinaryRole = _data["culinaryRole"];
        }
    }

    static fromJS(data: any): ComponentDescription {
        data = typeof data === 'object' ? data : {};
        let result = new ComponentDescription();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["quantity"] = this.quantity;
        data["singularUnit"] = this.singularUnit;
        data["pluralUnit"] = this.pluralUnit;
        data["culinaryRole"] = this.culinaryRole;
        return data;
    }
}

export interface IComponentDescription {
    id?: string | undefined;
    name?: string | undefined;
    quantity?: number | undefined;
    singularUnit?: string | undefined;
    pluralUnit?: string | undefined;
    culinaryRole?: string | undefined;
}

export class ComponentMatch implements IComponentMatch {
    id?: string | undefined;
    provider?: string | undefined;
    providerFoodId?: string | undefined;
    displayName?: string | undefined;
    brandName?: string | undefined;
    originalText?: string | undefined;
    description?: string | undefined;
    cookingMethod?: string | undefined;
    size?: string | undefined;
    rank?: number;
    selectedServingId?: ServingIdentifier;
    totalGrams?: number;
    servings?: ComponentServing[] | undefined;
    effectiveMultiplier?: number;
    effectiveQuantity?: number;
    inferred?: boolean;
    inferredReason?: string | undefined;
    searchText?: string | undefined;
    culinaryRole?: string | undefined;
    photoThumb?: string | undefined;
    photoHighRes?: string | undefined;
    isPending?: boolean;
    statusText?: string | undefined;

    constructor(data?: IComponentMatch) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.provider = _data["provider"];
            this.providerFoodId = _data["providerFoodId"];
            this.displayName = _data["displayName"];
            this.brandName = _data["brandName"];
            this.originalText = _data["originalText"];
            this.description = _data["description"];
            this.cookingMethod = _data["cookingMethod"];
            this.size = _data["size"];
            this.rank = _data["rank"];
            this.selectedServingId = _data["selectedServingId"] ? ServingIdentifier.fromJS(_data["selectedServingId"]) : <any>undefined;
            this.totalGrams = _data["totalGrams"];
            if (Array.isArray(_data["servings"])) {
                this.servings = [] as any;
                for (let item of _data["servings"])
                    this.servings!.push(ComponentServing.fromJS(item));
            }
            this.effectiveMultiplier = _data["effectiveMultiplier"];
            this.effectiveQuantity = _data["effectiveQuantity"];
            this.inferred = _data["inferred"];
            this.inferredReason = _data["inferredReason"];
            this.searchText = _data["searchText"];
            this.culinaryRole = _data["culinaryRole"];
            this.photoThumb = _data["photoThumb"];
            this.photoHighRes = _data["photoHighRes"];
            this.isPending = _data["isPending"];
            this.statusText = _data["statusText"];
        }
    }

    static fromJS(data: any): ComponentMatch {
        data = typeof data === 'object' ? data : {};
        let result = new ComponentMatch();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["provider"] = this.provider;
        data["providerFoodId"] = this.providerFoodId;
        data["displayName"] = this.displayName;
        data["brandName"] = this.brandName;
        data["originalText"] = this.originalText;
        data["description"] = this.description;
        data["cookingMethod"] = this.cookingMethod;
        data["size"] = this.size;
        data["rank"] = this.rank;
        data["selectedServingId"] = this.selectedServingId ? this.selectedServingId.toJSON() : <any>undefined;
        data["totalGrams"] = this.totalGrams;
        if (Array.isArray(this.servings)) {
            data["servings"] = [];
            for (let item of this.servings)
                data["servings"].push(item.toJSON());
        }
        data["effectiveMultiplier"] = this.effectiveMultiplier;
        data["effectiveQuantity"] = this.effectiveQuantity;
        data["inferred"] = this.inferred;
        data["inferredReason"] = this.inferredReason;
        data["searchText"] = this.searchText;
        data["culinaryRole"] = this.culinaryRole;
        data["photoThumb"] = this.photoThumb;
        data["photoHighRes"] = this.photoHighRes;
        data["isPending"] = this.isPending;
        data["statusText"] = this.statusText;
        return data;
    }
}

export interface IComponentMatch {
    id?: string | undefined;
    provider?: string | undefined;
    providerFoodId?: string | undefined;
    displayName?: string | undefined;
    brandName?: string | undefined;
    originalText?: string | undefined;
    description?: string | undefined;
    cookingMethod?: string | undefined;
    size?: string | undefined;
    rank?: number;
    selectedServingId?: ServingIdentifier;
    totalGrams?: number;
    servings?: ComponentServing[] | undefined;
    effectiveMultiplier?: number;
    effectiveQuantity?: number;
    inferred?: boolean;
    inferredReason?: string | undefined;
    searchText?: string | undefined;
    culinaryRole?: string | undefined;
    photoThumb?: string | undefined;
    photoHighRes?: string | undefined;
    isPending?: boolean;
    statusText?: string | undefined;
}

export class ComponentServing implements IComponentServing {
    id?: string | undefined;
    servingId?: ServingIdentifier;
    description?: string | undefined;
    baseQuantity?: number;
    baseUnit?: string | undefined;
    aiRecommendedScaleNumerator?: number | undefined;
    aiRecommendedScaleDenominator?: number | undefined;
    userConfirmedQuantity?: number | undefined;
    singularUnit?: string | undefined;
    pluralUnit?: string | undefined;
    metricServingAmount?: number | undefined;
    metricServingUnit?: string | undefined;
    numberOfUnits?: number | undefined;
    measurementDescription?: string | undefined;
    weightGramsPerUnit?: number | undefined;
    nutrients?: { [key: string]: number; } | undefined;
    apiServingKind?: UnitKind;
    isPending?: boolean;
    statusText?: string | undefined;

    constructor(data?: IComponentServing) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.servingId = _data["servingId"] ? ServingIdentifier.fromJS(_data["servingId"]) : <any>undefined;
            this.description = _data["description"];
            this.baseQuantity = _data["baseQuantity"];
            this.baseUnit = _data["baseUnit"];
            this.aiRecommendedScaleNumerator = _data["aiRecommendedScaleNumerator"];
            this.aiRecommendedScaleDenominator = _data["aiRecommendedScaleDenominator"];
            this.userConfirmedQuantity = _data["userConfirmedQuantity"];
            this.singularUnit = _data["singularUnit"];
            this.pluralUnit = _data["pluralUnit"];
            this.metricServingAmount = _data["metricServingAmount"];
            this.metricServingUnit = _data["metricServingUnit"];
            this.numberOfUnits = _data["numberOfUnits"];
            this.measurementDescription = _data["measurementDescription"];
            this.weightGramsPerUnit = _data["weightGramsPerUnit"];
            if (_data["nutrients"]) {
                this.nutrients = {} as any;
                for (let key in _data["nutrients"]) {
                    if (_data["nutrients"].hasOwnProperty(key))
                        (<any>this.nutrients)![key] = _data["nutrients"][key];
                }
            }
            this.apiServingKind = _data["apiServingKind"];
            this.isPending = _data["isPending"];
            this.statusText = _data["statusText"];
        }
    }

    static fromJS(data: any): ComponentServing {
        data = typeof data === 'object' ? data : {};
        let result = new ComponentServing();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["servingId"] = this.servingId ? this.servingId.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["baseQuantity"] = this.baseQuantity;
        data["baseUnit"] = this.baseUnit;
        data["aiRecommendedScaleNumerator"] = this.aiRecommendedScaleNumerator;
        data["aiRecommendedScaleDenominator"] = this.aiRecommendedScaleDenominator;
        data["userConfirmedQuantity"] = this.userConfirmedQuantity;
        data["singularUnit"] = this.singularUnit;
        data["pluralUnit"] = this.pluralUnit;
        data["metricServingAmount"] = this.metricServingAmount;
        data["metricServingUnit"] = this.metricServingUnit;
        data["numberOfUnits"] = this.numberOfUnits;
        data["measurementDescription"] = this.measurementDescription;
        data["weightGramsPerUnit"] = this.weightGramsPerUnit;
        if (this.nutrients) {
            data["nutrients"] = {};
            for (let key in this.nutrients) {
                if (this.nutrients.hasOwnProperty(key))
                    (<any>data["nutrients"])[key] = (<any>this.nutrients)[key];
            }
        }
        data["apiServingKind"] = this.apiServingKind;
        data["isPending"] = this.isPending;
        data["statusText"] = this.statusText;
        return data;
    }
}

export interface IComponentServing {
    id?: string | undefined;
    servingId?: ServingIdentifier;
    description?: string | undefined;
    baseQuantity?: number;
    baseUnit?: string | undefined;
    aiRecommendedScaleNumerator?: number | undefined;
    aiRecommendedScaleDenominator?: number | undefined;
    userConfirmedQuantity?: number | undefined;
    singularUnit?: string | undefined;
    pluralUnit?: string | undefined;
    metricServingAmount?: number | undefined;
    metricServingUnit?: string | undefined;
    numberOfUnits?: number | undefined;
    measurementDescription?: string | undefined;
    weightGramsPerUnit?: number | undefined;
    nutrients?: { [key: string]: number; } | undefined;
    apiServingKind?: UnitKind;
    isPending?: boolean;
    statusText?: string | undefined;
}

export class ConfirmGuidelineFileUploadRequest implements IConfirmGuidelineFileUploadRequest {
    objectName?: string | undefined;
    fileName?: string | undefined;
    contentType?: string | undefined;

    constructor(data?: IConfirmGuidelineFileUploadRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objectName = _data["objectName"];
            this.fileName = _data["fileName"];
            this.contentType = _data["contentType"];
        }
    }

    static fromJS(data: any): ConfirmGuidelineFileUploadRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ConfirmGuidelineFileUploadRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objectName"] = this.objectName;
        data["fileName"] = this.fileName;
        data["contentType"] = this.contentType;
        return data;
    }
}

export interface IConfirmGuidelineFileUploadRequest {
    objectName?: string | undefined;
    fileName?: string | undefined;
    contentType?: string | undefined;
}

export class ConfirmGuidelineFileUploadResponse implements IConfirmGuidelineFileUploadResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;
    openAiFileId?: string | undefined;
    openAiFileApiId?: string | undefined;
    vectorStoreId?: string | undefined;
    status?: string | undefined;
    cloudStorageObjectName?: string | undefined;

    constructor(data?: IConfirmGuidelineFileUploadResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.correlationId = _data["correlationId"];
            this.stackTrace = _data["stackTrace"];
            this.accountId = _data["accountId"];
            this.isPartial = _data["isPartial"];
            this.processingStage = _data["processingStage"];
            this.messageId = _data["messageId"];
            this.openAiFileId = _data["openAiFileId"];
            this.openAiFileApiId = _data["openAiFileApiId"];
            this.vectorStoreId = _data["vectorStoreId"];
            this.status = _data["status"];
            this.cloudStorageObjectName = _data["cloudStorageObjectName"];
        }
    }

    static fromJS(data: any): ConfirmGuidelineFileUploadResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ConfirmGuidelineFileUploadResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["correlationId"] = this.correlationId;
        data["stackTrace"] = this.stackTrace;
        data["accountId"] = this.accountId;
        data["isPartial"] = this.isPartial;
        data["processingStage"] = this.processingStage;
        data["messageId"] = this.messageId;
        data["openAiFileId"] = this.openAiFileId;
        data["openAiFileApiId"] = this.openAiFileApiId;
        data["vectorStoreId"] = this.vectorStoreId;
        data["status"] = this.status;
        data["cloudStorageObjectName"] = this.cloudStorageObjectName;
        return data;
    }
}

export interface IConfirmGuidelineFileUploadResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;
    openAiFileId?: string | undefined;
    openAiFileApiId?: string | undefined;
    vectorStoreId?: string | undefined;
    status?: string | undefined;
    cloudStorageObjectName?: string | undefined;
}

export class CreateSharedMealRequest implements ICreateSharedMealRequest {
    foodEntryId?: string | undefined;

    constructor(data?: ICreateSharedMealRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.foodEntryId = _data["foodEntryId"];
        }
    }

    static fromJS(data: any): CreateSharedMealRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSharedMealRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["foodEntryId"] = this.foodEntryId;
        return data;
    }
}

export interface ICreateSharedMealRequest {
    foodEntryId?: string | undefined;
}

export class CreateSharedMealResponse implements ICreateSharedMealResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;
    shareToken?: string | undefined;
    shareUrl?: string | undefined;
    preview?: MealPreview;
    expiresDateUtc?: Date;

    constructor(data?: ICreateSharedMealResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.correlationId = _data["correlationId"];
            this.stackTrace = _data["stackTrace"];
            this.accountId = _data["accountId"];
            this.isPartial = _data["isPartial"];
            this.processingStage = _data["processingStage"];
            this.messageId = _data["messageId"];
            this.shareToken = _data["shareToken"];
            this.shareUrl = _data["shareUrl"];
            this.preview = _data["preview"] ? MealPreview.fromJS(_data["preview"]) : <any>undefined;
            this.expiresDateUtc = _data["expiresDateUtc"] ? new Date(_data["expiresDateUtc"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateSharedMealResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSharedMealResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["correlationId"] = this.correlationId;
        data["stackTrace"] = this.stackTrace;
        data["accountId"] = this.accountId;
        data["isPartial"] = this.isPartial;
        data["processingStage"] = this.processingStage;
        data["messageId"] = this.messageId;
        data["shareToken"] = this.shareToken;
        data["shareUrl"] = this.shareUrl;
        data["preview"] = this.preview ? this.preview.toJSON() : <any>undefined;
        data["expiresDateUtc"] = this.expiresDateUtc ? this.expiresDateUtc.toISOString() : <any>undefined;
        return data;
    }
}

export interface ICreateSharedMealResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;
    shareToken?: string | undefined;
    shareUrl?: string | undefined;
    preview?: MealPreview;
    expiresDateUtc?: Date;
}

export class DailySummary implements IDailySummary {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    accountId?: string | undefined;
    localDateKey?: string | undefined;
    nutrients?: NutrientBreakdown[] | undefined;
    foods?: FoodBreakdown[] | undefined;
    foodEntries?: FoodEntryBreakdown[] | undefined;

    constructor(data?: IDailySummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdDateUtc = _data["createdDateUtc"] ? new Date(_data["createdDateUtc"].toString()) : <any>undefined;
            this.lastUpdatedDateUtc = _data["lastUpdatedDateUtc"] ? new Date(_data["lastUpdatedDateUtc"].toString()) : <any>undefined;
            this.accountId = _data["accountId"];
            this.localDateKey = _data["localDateKey"];
            if (Array.isArray(_data["nutrients"])) {
                this.nutrients = [] as any;
                for (let item of _data["nutrients"])
                    this.nutrients!.push(NutrientBreakdown.fromJS(item));
            }
            if (Array.isArray(_data["foods"])) {
                this.foods = [] as any;
                for (let item of _data["foods"])
                    this.foods!.push(FoodBreakdown.fromJS(item));
            }
            if (Array.isArray(_data["foodEntries"])) {
                this.foodEntries = [] as any;
                for (let item of _data["foodEntries"])
                    this.foodEntries!.push(FoodEntryBreakdown.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DailySummary {
        data = typeof data === 'object' ? data : {};
        let result = new DailySummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdDateUtc"] = this.createdDateUtc ? this.createdDateUtc.toISOString() : <any>undefined;
        data["lastUpdatedDateUtc"] = this.lastUpdatedDateUtc ? this.lastUpdatedDateUtc.toISOString() : <any>undefined;
        data["accountId"] = this.accountId;
        data["localDateKey"] = this.localDateKey;
        if (Array.isArray(this.nutrients)) {
            data["nutrients"] = [];
            for (let item of this.nutrients)
                data["nutrients"].push(item.toJSON());
        }
        if (Array.isArray(this.foods)) {
            data["foods"] = [];
            for (let item of this.foods)
                data["foods"].push(item.toJSON());
        }
        if (Array.isArray(this.foodEntries)) {
            data["foodEntries"] = [];
            for (let item of this.foodEntries)
                data["foodEntries"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDailySummary {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    accountId?: string | undefined;
    localDateKey?: string | undefined;
    nutrients?: NutrientBreakdown[] | undefined;
    foods?: FoodBreakdown[] | undefined;
    foodEntries?: FoodEntryBreakdown[] | undefined;
}

export class DeleteAccountRequest implements IDeleteAccountRequest {
    accountId!: string;
    confirmDelete?: boolean;

    constructor(data?: IDeleteAccountRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountId = _data["accountId"];
            this.confirmDelete = _data["confirmDelete"];
        }
    }

    static fromJS(data: any): DeleteAccountRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteAccountRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountId"] = this.accountId;
        data["confirmDelete"] = this.confirmDelete;
        return data;
    }
}

export interface IDeleteAccountRequest {
    accountId: string;
    confirmDelete?: boolean;
}

export class DeleteAccountResponse implements IDeleteAccountResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;
    accountDeleted?: boolean;
    deletedAccountId?: string | undefined;
    totalRecordsDeleted?: number;
    deletedRecordsByType?: { [key: string]: number; } | undefined;

    constructor(data?: IDeleteAccountResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.correlationId = _data["correlationId"];
            this.stackTrace = _data["stackTrace"];
            this.accountId = _data["accountId"];
            this.isPartial = _data["isPartial"];
            this.processingStage = _data["processingStage"];
            this.messageId = _data["messageId"];
            this.accountDeleted = _data["accountDeleted"];
            this.deletedAccountId = _data["deletedAccountId"];
            this.totalRecordsDeleted = _data["totalRecordsDeleted"];
            if (_data["deletedRecordsByType"]) {
                this.deletedRecordsByType = {} as any;
                for (let key in _data["deletedRecordsByType"]) {
                    if (_data["deletedRecordsByType"].hasOwnProperty(key))
                        (<any>this.deletedRecordsByType)![key] = _data["deletedRecordsByType"][key];
                }
            }
        }
    }

    static fromJS(data: any): DeleteAccountResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteAccountResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["correlationId"] = this.correlationId;
        data["stackTrace"] = this.stackTrace;
        data["accountId"] = this.accountId;
        data["isPartial"] = this.isPartial;
        data["processingStage"] = this.processingStage;
        data["messageId"] = this.messageId;
        data["accountDeleted"] = this.accountDeleted;
        data["deletedAccountId"] = this.deletedAccountId;
        data["totalRecordsDeleted"] = this.totalRecordsDeleted;
        if (this.deletedRecordsByType) {
            data["deletedRecordsByType"] = {};
            for (let key in this.deletedRecordsByType) {
                if (this.deletedRecordsByType.hasOwnProperty(key))
                    (<any>data["deletedRecordsByType"])[key] = (<any>this.deletedRecordsByType)[key];
            }
        }
        return data;
    }
}

export interface IDeleteAccountResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;
    accountDeleted?: boolean;
    deletedAccountId?: string | undefined;
    totalRecordsDeleted?: number;
    deletedRecordsByType?: { [key: string]: number; } | undefined;
}

export class DeleteFeedbackRequest implements IDeleteFeedbackRequest {
    feedbackId?: string | undefined;

    constructor(data?: IDeleteFeedbackRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.feedbackId = _data["feedbackId"];
        }
    }

    static fromJS(data: any): DeleteFeedbackRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteFeedbackRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["feedbackId"] = this.feedbackId;
        return data;
    }
}

export interface IDeleteFeedbackRequest {
    feedbackId?: string | undefined;
}

export class DeleteFeedbackResponse implements IDeleteFeedbackResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;
    deleted?: boolean;

    constructor(data?: IDeleteFeedbackResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.correlationId = _data["correlationId"];
            this.stackTrace = _data["stackTrace"];
            this.accountId = _data["accountId"];
            this.isPartial = _data["isPartial"];
            this.processingStage = _data["processingStage"];
            this.messageId = _data["messageId"];
            this.deleted = _data["deleted"];
        }
    }

    static fromJS(data: any): DeleteFeedbackResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteFeedbackResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["correlationId"] = this.correlationId;
        data["stackTrace"] = this.stackTrace;
        data["accountId"] = this.accountId;
        data["isPartial"] = this.isPartial;
        data["processingStage"] = this.processingStage;
        data["messageId"] = this.messageId;
        data["deleted"] = this.deleted;
        return data;
    }
}

export interface IDeleteFeedbackResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;
    deleted?: boolean;
}

export class DeleteFoodEntryRequest implements IDeleteFoodEntryRequest {
    foodItemIds?: string[] | undefined;

    constructor(data?: IDeleteFoodEntryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["foodItemIds"])) {
                this.foodItemIds = [] as any;
                for (let item of _data["foodItemIds"])
                    this.foodItemIds!.push(item);
            }
        }
    }

    static fromJS(data: any): DeleteFoodEntryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteFoodEntryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.foodItemIds)) {
            data["foodItemIds"] = [];
            for (let item of this.foodItemIds)
                data["foodItemIds"].push(item);
        }
        return data;
    }
}

export interface IDeleteFoodEntryRequest {
    foodItemIds?: string[] | undefined;
}

export class DeleteFoodEntryResponse implements IDeleteFoodEntryResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;

    constructor(data?: IDeleteFoodEntryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.correlationId = _data["correlationId"];
            this.stackTrace = _data["stackTrace"];
            this.accountId = _data["accountId"];
            this.isPartial = _data["isPartial"];
            this.processingStage = _data["processingStage"];
            this.messageId = _data["messageId"];
        }
    }

    static fromJS(data: any): DeleteFoodEntryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteFoodEntryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["correlationId"] = this.correlationId;
        data["stackTrace"] = this.stackTrace;
        data["accountId"] = this.accountId;
        data["isPartial"] = this.isPartial;
        data["processingStage"] = this.processingStage;
        data["messageId"] = this.messageId;
        return data;
    }
}

export interface IDeleteFoodEntryResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;
}

export class DeleteGuidelineFileRequest implements IDeleteGuidelineFileRequest {
    openAiFileId?: string | undefined;

    constructor(data?: IDeleteGuidelineFileRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.openAiFileId = _data["openAiFileId"];
        }
    }

    static fromJS(data: any): DeleteGuidelineFileRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteGuidelineFileRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["openAiFileId"] = this.openAiFileId;
        return data;
    }
}

export interface IDeleteGuidelineFileRequest {
    openAiFileId?: string | undefined;
}

export class DeleteGuidelineFileResponse implements IDeleteGuidelineFileResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;

    constructor(data?: IDeleteGuidelineFileResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.correlationId = _data["correlationId"];
            this.stackTrace = _data["stackTrace"];
            this.accountId = _data["accountId"];
            this.isPartial = _data["isPartial"];
            this.processingStage = _data["processingStage"];
            this.messageId = _data["messageId"];
        }
    }

    static fromJS(data: any): DeleteGuidelineFileResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteGuidelineFileResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["correlationId"] = this.correlationId;
        data["stackTrace"] = this.stackTrace;
        data["accountId"] = this.accountId;
        data["isPartial"] = this.isPartial;
        data["processingStage"] = this.processingStage;
        data["messageId"] = this.messageId;
        return data;
    }
}

export interface IDeleteGuidelineFileResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;
}

export class DirectLogMealRequest implements IDirectLogMealRequest {
    foodPhrase?: string | undefined;
    messageId?: string | undefined;
    localDateKey?: string | undefined;

    constructor(data?: IDirectLogMealRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.foodPhrase = _data["foodPhrase"];
            this.messageId = _data["messageId"];
            this.localDateKey = _data["localDateKey"];
        }
    }

    static fromJS(data: any): DirectLogMealRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DirectLogMealRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["foodPhrase"] = this.foodPhrase;
        data["messageId"] = this.messageId;
        data["localDateKey"] = this.localDateKey;
        return data;
    }
}

export interface IDirectLogMealRequest {
    foodPhrase?: string | undefined;
    messageId?: string | undefined;
    localDateKey?: string | undefined;
}

export class EditFoodSelectionRequest implements IEditFoodSelectionRequest {
    foodEntryId!: string;
    foodId?: string | undefined;
    componentId?: string | undefined;
    localDateKey?: string | undefined;
    isInlineEdit?: boolean;

    constructor(data?: IEditFoodSelectionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.foodEntryId = _data["foodEntryId"];
            this.foodId = _data["foodId"];
            this.componentId = _data["componentId"];
            this.localDateKey = _data["localDateKey"];
            this.isInlineEdit = _data["isInlineEdit"];
        }
    }

    static fromJS(data: any): EditFoodSelectionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new EditFoodSelectionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["foodEntryId"] = this.foodEntryId;
        data["foodId"] = this.foodId;
        data["componentId"] = this.componentId;
        data["localDateKey"] = this.localDateKey;
        data["isInlineEdit"] = this.isInlineEdit;
        return data;
    }
}

export interface IEditFoodSelectionRequest {
    foodEntryId: string;
    foodId?: string | undefined;
    componentId?: string | undefined;
    localDateKey?: string | undefined;
    isInlineEdit?: boolean;
}

export class ErrorDto implements IErrorDto {
    errorMessage?: string | undefined;
    errorCode?: string | undefined;

    constructor(data?: IErrorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
        }
    }

    static fromJS(data: any): ErrorDto {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        return data;
    }
}

export interface IErrorDto {
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
}

export class FavoriteFoodDto implements IFavoriteFoodDto {
    id?: string | undefined;
    customLabel?: string | undefined;
    emoji?: string | undefined;
    foodSnapshot?: Food;
    timesLogged?: number;
    lastUsedDateUtc?: Date | undefined;
    createdDateUtc?: Date;

    constructor(data?: IFavoriteFoodDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.customLabel = _data["customLabel"];
            this.emoji = _data["emoji"];
            this.foodSnapshot = _data["foodSnapshot"] ? Food.fromJS(_data["foodSnapshot"]) : <any>undefined;
            this.timesLogged = _data["timesLogged"];
            this.lastUsedDateUtc = _data["lastUsedDateUtc"] ? new Date(_data["lastUsedDateUtc"].toString()) : <any>undefined;
            this.createdDateUtc = _data["createdDateUtc"] ? new Date(_data["createdDateUtc"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): FavoriteFoodDto {
        data = typeof data === 'object' ? data : {};
        let result = new FavoriteFoodDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["customLabel"] = this.customLabel;
        data["emoji"] = this.emoji;
        data["foodSnapshot"] = this.foodSnapshot ? this.foodSnapshot.toJSON() : <any>undefined;
        data["timesLogged"] = this.timesLogged;
        data["lastUsedDateUtc"] = this.lastUsedDateUtc ? this.lastUsedDateUtc.toISOString() : <any>undefined;
        data["createdDateUtc"] = this.createdDateUtc ? this.createdDateUtc.toISOString() : <any>undefined;
        return data;
    }
}

export interface IFavoriteFoodDto {
    id?: string | undefined;
    customLabel?: string | undefined;
    emoji?: string | undefined;
    foodSnapshot?: Food;
    timesLogged?: number;
    lastUsedDateUtc?: Date | undefined;
    createdDateUtc?: Date;
}

export class FeedbackEntry implements IFeedbackEntry {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    accountId?: string | undefined;
    feedbackType?: string | undefined;
    message?: string | undefined;
    clientContext?: TelemetryContext;
    serverContext?: TelemetryContext;
    isCompleted?: boolean;
    completedDateUtc?: Date | undefined;
    completionNote?: string | undefined;
    completedByAccountId?: string | undefined;
    isAssistantResponseShown?: boolean;
    assistantResponseShownDateUtc?: Date | undefined;
    localDateKey?: string | undefined;

    constructor(data?: IFeedbackEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdDateUtc = _data["createdDateUtc"] ? new Date(_data["createdDateUtc"].toString()) : <any>undefined;
            this.lastUpdatedDateUtc = _data["lastUpdatedDateUtc"] ? new Date(_data["lastUpdatedDateUtc"].toString()) : <any>undefined;
            this.accountId = _data["accountId"];
            this.feedbackType = _data["feedbackType"];
            this.message = _data["message"];
            this.clientContext = _data["clientContext"] ? TelemetryContext.fromJS(_data["clientContext"]) : <any>undefined;
            this.serverContext = _data["serverContext"] ? TelemetryContext.fromJS(_data["serverContext"]) : <any>undefined;
            this.isCompleted = _data["isCompleted"];
            this.completedDateUtc = _data["completedDateUtc"] ? new Date(_data["completedDateUtc"].toString()) : <any>undefined;
            this.completionNote = _data["completionNote"];
            this.completedByAccountId = _data["completedByAccountId"];
            this.isAssistantResponseShown = _data["isAssistantResponseShown"];
            this.assistantResponseShownDateUtc = _data["assistantResponseShownDateUtc"] ? new Date(_data["assistantResponseShownDateUtc"].toString()) : <any>undefined;
            this.localDateKey = _data["localDateKey"];
        }
    }

    static fromJS(data: any): FeedbackEntry {
        data = typeof data === 'object' ? data : {};
        let result = new FeedbackEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdDateUtc"] = this.createdDateUtc ? this.createdDateUtc.toISOString() : <any>undefined;
        data["lastUpdatedDateUtc"] = this.lastUpdatedDateUtc ? this.lastUpdatedDateUtc.toISOString() : <any>undefined;
        data["accountId"] = this.accountId;
        data["feedbackType"] = this.feedbackType;
        data["message"] = this.message;
        data["clientContext"] = this.clientContext ? this.clientContext.toJSON() : <any>undefined;
        data["serverContext"] = this.serverContext ? this.serverContext.toJSON() : <any>undefined;
        data["isCompleted"] = this.isCompleted;
        data["completedDateUtc"] = this.completedDateUtc ? this.completedDateUtc.toISOString() : <any>undefined;
        data["completionNote"] = this.completionNote;
        data["completedByAccountId"] = this.completedByAccountId;
        data["isAssistantResponseShown"] = this.isAssistantResponseShown;
        data["assistantResponseShownDateUtc"] = this.assistantResponseShownDateUtc ? this.assistantResponseShownDateUtc.toISOString() : <any>undefined;
        data["localDateKey"] = this.localDateKey;
        return data;
    }
}

export interface IFeedbackEntry {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    accountId?: string | undefined;
    feedbackType?: string | undefined;
    message?: string | undefined;
    clientContext?: TelemetryContext;
    serverContext?: TelemetryContext;
    isCompleted?: boolean;
    completedDateUtc?: Date | undefined;
    completionNote?: string | undefined;
    completedByAccountId?: string | undefined;
    isAssistantResponseShown?: boolean;
    assistantResponseShownDateUtc?: Date | undefined;
    localDateKey?: string | undefined;
}

export class FeedbackWithAccount implements IFeedbackWithAccount {
    feedback?: FeedbackEntry;
    accountEmail?: string | undefined;
    accountId?: string | undefined;
    accountCreatedDate?: Date | undefined;

    constructor(data?: IFeedbackWithAccount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.feedback = _data["feedback"] ? FeedbackEntry.fromJS(_data["feedback"]) : <any>undefined;
            this.accountEmail = _data["accountEmail"];
            this.accountId = _data["accountId"];
            this.accountCreatedDate = _data["accountCreatedDate"] ? new Date(_data["accountCreatedDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): FeedbackWithAccount {
        data = typeof data === 'object' ? data : {};
        let result = new FeedbackWithAccount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["feedback"] = this.feedback ? this.feedback.toJSON() : <any>undefined;
        data["accountEmail"] = this.accountEmail;
        data["accountId"] = this.accountId;
        data["accountCreatedDate"] = this.accountCreatedDate ? this.accountCreatedDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IFeedbackWithAccount {
    feedback?: FeedbackEntry;
    accountEmail?: string | undefined;
    accountId?: string | undefined;
    accountCreatedDate?: Date | undefined;
}

export class Food implements IFood {
    id?: string | undefined;
    name?: string | undefined;
    quantity?: number;
    singularUnit?: string | undefined;
    pluralUnit?: string | undefined;
    description?: string | undefined;
    brand?: string | undefined;
    originalPhrase?: string | undefined;
    photoThumb?: string | undefined;
    photoHighRes?: string | undefined;
    components?: Component[] | undefined;
    isPending?: boolean;
    statusText?: string | undefined;

    constructor(data?: IFood) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.quantity = _data["quantity"];
            this.singularUnit = _data["singularUnit"];
            this.pluralUnit = _data["pluralUnit"];
            this.description = _data["description"];
            this.brand = _data["brand"];
            this.originalPhrase = _data["originalPhrase"];
            this.photoThumb = _data["photoThumb"];
            this.photoHighRes = _data["photoHighRes"];
            if (Array.isArray(_data["components"])) {
                this.components = [] as any;
                for (let item of _data["components"])
                    this.components!.push(Component.fromJS(item));
            }
            this.isPending = _data["isPending"];
            this.statusText = _data["statusText"];
        }
    }

    static fromJS(data: any): Food {
        data = typeof data === 'object' ? data : {};
        let result = new Food();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["quantity"] = this.quantity;
        data["singularUnit"] = this.singularUnit;
        data["pluralUnit"] = this.pluralUnit;
        data["description"] = this.description;
        data["brand"] = this.brand;
        data["originalPhrase"] = this.originalPhrase;
        data["photoThumb"] = this.photoThumb;
        data["photoHighRes"] = this.photoHighRes;
        if (Array.isArray(this.components)) {
            data["components"] = [];
            for (let item of this.components)
                data["components"].push(item.toJSON());
        }
        data["isPending"] = this.isPending;
        data["statusText"] = this.statusText;
        return data;
    }
}

export interface IFood {
    id?: string | undefined;
    name?: string | undefined;
    quantity?: number;
    singularUnit?: string | undefined;
    pluralUnit?: string | undefined;
    description?: string | undefined;
    brand?: string | undefined;
    originalPhrase?: string | undefined;
    photoThumb?: string | undefined;
    photoHighRes?: string | undefined;
    components?: Component[] | undefined;
    isPending?: boolean;
    statusText?: string | undefined;
}

export class FoodBreakdown implements IFoodBreakdown {
    foodItemIds?: string[] | undefined;
    foodEntryId?: string | undefined;
    foodId?: string | undefined;
    componentId?: string | undefined;
    name?: string | undefined;
    brandName?: string | undefined;
    quantity?: number;
    foodUnit?: string | undefined;
    totalAmount?: number;
    unit?: string | undefined;
    nutrients?: NutrientContribution[] | undefined;
    components?: ComponentBreakdown[] | undefined;
    componentCount?: number;

    constructor(data?: IFoodBreakdown) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["foodItemIds"])) {
                this.foodItemIds = [] as any;
                for (let item of _data["foodItemIds"])
                    this.foodItemIds!.push(item);
            }
            this.foodEntryId = _data["foodEntryId"];
            this.foodId = _data["foodId"];
            this.componentId = _data["componentId"];
            this.name = _data["name"];
            this.brandName = _data["brandName"];
            this.quantity = _data["quantity"];
            this.foodUnit = _data["foodUnit"];
            this.totalAmount = _data["totalAmount"];
            this.unit = _data["unit"];
            if (Array.isArray(_data["nutrients"])) {
                this.nutrients = [] as any;
                for (let item of _data["nutrients"])
                    this.nutrients!.push(NutrientContribution.fromJS(item));
            }
            if (Array.isArray(_data["components"])) {
                this.components = [] as any;
                for (let item of _data["components"])
                    this.components!.push(ComponentBreakdown.fromJS(item));
            }
            this.componentCount = _data["componentCount"];
        }
    }

    static fromJS(data: any): FoodBreakdown {
        data = typeof data === 'object' ? data : {};
        let result = new FoodBreakdown();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.foodItemIds)) {
            data["foodItemIds"] = [];
            for (let item of this.foodItemIds)
                data["foodItemIds"].push(item);
        }
        data["foodEntryId"] = this.foodEntryId;
        data["foodId"] = this.foodId;
        data["componentId"] = this.componentId;
        data["name"] = this.name;
        data["brandName"] = this.brandName;
        data["quantity"] = this.quantity;
        data["foodUnit"] = this.foodUnit;
        data["totalAmount"] = this.totalAmount;
        data["unit"] = this.unit;
        if (Array.isArray(this.nutrients)) {
            data["nutrients"] = [];
            for (let item of this.nutrients)
                data["nutrients"].push(item.toJSON());
        }
        if (Array.isArray(this.components)) {
            data["components"] = [];
            for (let item of this.components)
                data["components"].push(item.toJSON());
        }
        data["componentCount"] = this.componentCount;
        return data;
    }
}

export interface IFoodBreakdown {
    foodItemIds?: string[] | undefined;
    foodEntryId?: string | undefined;
    foodId?: string | undefined;
    componentId?: string | undefined;
    name?: string | undefined;
    brandName?: string | undefined;
    quantity?: number;
    foodUnit?: string | undefined;
    totalAmount?: number;
    unit?: string | undefined;
    nutrients?: NutrientContribution[] | undefined;
    components?: ComponentBreakdown[] | undefined;
    componentCount?: number;
}

export class FoodContribution implements IFoodContribution {
    name?: string | undefined;
    brandName?: string | undefined;
    amount?: number;
    unit?: string | undefined;
    foodUnit?: string | undefined;
    displayQuantity?: number;
    foodEntryId?: string | undefined;
    foodId?: string | undefined;
    componentId?: string | undefined;

    constructor(data?: IFoodContribution) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.brandName = _data["brandName"];
            this.amount = _data["amount"];
            this.unit = _data["unit"];
            this.foodUnit = _data["foodUnit"];
            this.displayQuantity = _data["displayQuantity"];
            this.foodEntryId = _data["foodEntryId"];
            this.foodId = _data["foodId"];
            this.componentId = _data["componentId"];
        }
    }

    static fromJS(data: any): FoodContribution {
        data = typeof data === 'object' ? data : {};
        let result = new FoodContribution();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["brandName"] = this.brandName;
        data["amount"] = this.amount;
        data["unit"] = this.unit;
        data["foodUnit"] = this.foodUnit;
        data["displayQuantity"] = this.displayQuantity;
        data["foodEntryId"] = this.foodEntryId;
        data["foodId"] = this.foodId;
        data["componentId"] = this.componentId;
        return data;
    }
}

export interface IFoodContribution {
    name?: string | undefined;
    brandName?: string | undefined;
    amount?: number;
    unit?: string | undefined;
    foodUnit?: string | undefined;
    displayQuantity?: number;
    foodEntryId?: string | undefined;
    foodId?: string | undefined;
    componentId?: string | undefined;
}

export class FoodEntryBreakdown implements IFoodEntryBreakdown {
    foodEntryId?: string | undefined;
    entryName?: string | undefined;
    localDateKey?: string | undefined;
    createdDateUtc?: Date;
    foods?: FoodBreakdown[] | undefined;
    nutrients?: NutrientContribution[] | undefined;

    constructor(data?: IFoodEntryBreakdown) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.foodEntryId = _data["foodEntryId"];
            this.entryName = _data["entryName"];
            this.localDateKey = _data["localDateKey"];
            this.createdDateUtc = _data["createdDateUtc"] ? new Date(_data["createdDateUtc"].toString()) : <any>undefined;
            if (Array.isArray(_data["foods"])) {
                this.foods = [] as any;
                for (let item of _data["foods"])
                    this.foods!.push(FoodBreakdown.fromJS(item));
            }
            if (Array.isArray(_data["nutrients"])) {
                this.nutrients = [] as any;
                for (let item of _data["nutrients"])
                    this.nutrients!.push(NutrientContribution.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FoodEntryBreakdown {
        data = typeof data === 'object' ? data : {};
        let result = new FoodEntryBreakdown();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["foodEntryId"] = this.foodEntryId;
        data["entryName"] = this.entryName;
        data["localDateKey"] = this.localDateKey;
        data["createdDateUtc"] = this.createdDateUtc ? this.createdDateUtc.toISOString() : <any>undefined;
        if (Array.isArray(this.foods)) {
            data["foods"] = [];
            for (let item of this.foods)
                data["foods"].push(item.toJSON());
        }
        if (Array.isArray(this.nutrients)) {
            data["nutrients"] = [];
            for (let item of this.nutrients)
                data["nutrients"].push(item.toJSON());
        }
        return data;
    }
}

export interface IFoodEntryBreakdown {
    foodEntryId?: string | undefined;
    entryName?: string | undefined;
    localDateKey?: string | undefined;
    createdDateUtc?: Date;
    foods?: FoodBreakdown[] | undefined;
    nutrients?: NutrientContribution[] | undefined;
}

export class FoodPreview implements IFoodPreview {
    name?: string | undefined;
    componentNames?: string[] | undefined;

    constructor(data?: IFoodPreview) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["componentNames"])) {
                this.componentNames = [] as any;
                for (let item of _data["componentNames"])
                    this.componentNames!.push(item);
            }
        }
    }

    static fromJS(data: any): FoodPreview {
        data = typeof data === 'object' ? data : {};
        let result = new FoodPreview();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.componentNames)) {
            data["componentNames"] = [];
            for (let item of this.componentNames)
                data["componentNames"].push(item);
        }
        return data;
    }
}

export interface IFoodPreview {
    name?: string | undefined;
    componentNames?: string[] | undefined;
}

export class GetAccountDataCountsRequest implements IGetAccountDataCountsRequest {
    accountId?: string | undefined;

    constructor(data?: IGetAccountDataCountsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountId = _data["accountId"];
        }
    }

    static fromJS(data: any): GetAccountDataCountsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetAccountDataCountsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountId"] = this.accountId;
        return data;
    }
}

export interface IGetAccountDataCountsRequest {
    accountId?: string | undefined;
}

export class GetAccountDataCountsResponse implements IGetAccountDataCountsResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;
    accountId?: string | undefined;
    dataCounts?: { [key: string]: number; } | undefined;
    totalDataCount?: number;

    constructor(data?: IGetAccountDataCountsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.correlationId = _data["correlationId"];
            this.stackTrace = _data["stackTrace"];
            this.isPartial = _data["isPartial"];
            this.processingStage = _data["processingStage"];
            this.messageId = _data["messageId"];
            this.accountId = _data["accountId"];
            if (_data["dataCounts"]) {
                this.dataCounts = {} as any;
                for (let key in _data["dataCounts"]) {
                    if (_data["dataCounts"].hasOwnProperty(key))
                        (<any>this.dataCounts)![key] = _data["dataCounts"][key];
                }
            }
            this.totalDataCount = _data["totalDataCount"];
        }
    }

    static fromJS(data: any): GetAccountDataCountsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetAccountDataCountsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["correlationId"] = this.correlationId;
        data["stackTrace"] = this.stackTrace;
        data["isPartial"] = this.isPartial;
        data["processingStage"] = this.processingStage;
        data["messageId"] = this.messageId;
        data["accountId"] = this.accountId;
        if (this.dataCounts) {
            data["dataCounts"] = {};
            for (let key in this.dataCounts) {
                if (this.dataCounts.hasOwnProperty(key))
                    (<any>data["dataCounts"])[key] = (<any>this.dataCounts)[key];
            }
        }
        data["totalDataCount"] = this.totalDataCount;
        return data;
    }
}

export interface IGetAccountDataCountsResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;
    accountId?: string | undefined;
    dataCounts?: { [key: string]: number; } | undefined;
    totalDataCount?: number;
}

export class GetAllAccountsRequest implements IGetAllAccountsRequest {

    constructor(data?: IGetAllAccountsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): GetAllAccountsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllAccountsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IGetAllAccountsRequest {
}

export class GetAllAccountsResponse implements IGetAllAccountsResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;
    accounts?: Account[] | undefined;

    constructor(data?: IGetAllAccountsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.correlationId = _data["correlationId"];
            this.stackTrace = _data["stackTrace"];
            this.accountId = _data["accountId"];
            this.isPartial = _data["isPartial"];
            this.processingStage = _data["processingStage"];
            this.messageId = _data["messageId"];
            if (Array.isArray(_data["accounts"])) {
                this.accounts = [] as any;
                for (let item of _data["accounts"])
                    this.accounts!.push(Account.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetAllAccountsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllAccountsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["correlationId"] = this.correlationId;
        data["stackTrace"] = this.stackTrace;
        data["accountId"] = this.accountId;
        data["isPartial"] = this.isPartial;
        data["processingStage"] = this.processingStage;
        data["messageId"] = this.messageId;
        if (Array.isArray(this.accounts)) {
            data["accounts"] = [];
            for (let item of this.accounts)
                data["accounts"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetAllAccountsResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;
    accounts?: Account[] | undefined;
}

export class GetChatMessagesRequest implements IGetChatMessagesRequest {
    localDateKey!: string;

    constructor(data?: IGetChatMessagesRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.localDateKey = _data["localDateKey"];
        }
    }

    static fromJS(data: any): GetChatMessagesRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetChatMessagesRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["localDateKey"] = this.localDateKey;
        return data;
    }
}

export interface IGetChatMessagesRequest {
    localDateKey: string;
}

export class GetDetailedSummaryRequest implements IGetDetailedSummaryRequest {
    localDateKey?: string | undefined;

    constructor(data?: IGetDetailedSummaryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.localDateKey = _data["localDateKey"];
        }
    }

    static fromJS(data: any): GetDetailedSummaryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetDetailedSummaryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["localDateKey"] = this.localDateKey;
        return data;
    }
}

export interface IGetDetailedSummaryRequest {
    localDateKey?: string | undefined;
}

export class GetDetailedSummaryResponse implements IGetDetailedSummaryResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;
    dailySummary?: DailySummary;

    constructor(data?: IGetDetailedSummaryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.correlationId = _data["correlationId"];
            this.stackTrace = _data["stackTrace"];
            this.accountId = _data["accountId"];
            this.isPartial = _data["isPartial"];
            this.processingStage = _data["processingStage"];
            this.messageId = _data["messageId"];
            this.dailySummary = _data["dailySummary"] ? DailySummary.fromJS(_data["dailySummary"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetDetailedSummaryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetDetailedSummaryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["correlationId"] = this.correlationId;
        data["stackTrace"] = this.stackTrace;
        data["accountId"] = this.accountId;
        data["isPartial"] = this.isPartial;
        data["processingStage"] = this.processingStage;
        data["messageId"] = this.messageId;
        data["dailySummary"] = this.dailySummary ? this.dailySummary.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetDetailedSummaryResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;
    dailySummary?: DailySummary;
}

export class GetFavoritesResponse implements IGetFavoritesResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;
    favorites?: FavoriteFoodDto[] | undefined;

    constructor(data?: IGetFavoritesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.correlationId = _data["correlationId"];
            this.stackTrace = _data["stackTrace"];
            this.accountId = _data["accountId"];
            this.isPartial = _data["isPartial"];
            this.processingStage = _data["processingStage"];
            this.messageId = _data["messageId"];
            if (Array.isArray(_data["favorites"])) {
                this.favorites = [] as any;
                for (let item of _data["favorites"])
                    this.favorites!.push(FavoriteFoodDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetFavoritesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetFavoritesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["correlationId"] = this.correlationId;
        data["stackTrace"] = this.stackTrace;
        data["accountId"] = this.accountId;
        data["isPartial"] = this.isPartial;
        data["processingStage"] = this.processingStage;
        data["messageId"] = this.messageId;
        if (Array.isArray(this.favorites)) {
            data["favorites"] = [];
            for (let item of this.favorites)
                data["favorites"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetFavoritesResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;
    favorites?: FavoriteFoodDto[] | undefined;
}

export class GetFeedbackWithAccountInfoRequest implements IGetFeedbackWithAccountInfoRequest {
    feedbackType?: string | undefined;
    accountId?: string | undefined;
    completedOnly?: boolean;
    incompleteOnly?: boolean;
    accountEmail?: string | undefined;

    constructor(data?: IGetFeedbackWithAccountInfoRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.feedbackType = _data["feedbackType"];
            this.accountId = _data["accountId"];
            this.completedOnly = _data["completedOnly"];
            this.incompleteOnly = _data["incompleteOnly"];
            this.accountEmail = _data["accountEmail"];
        }
    }

    static fromJS(data: any): GetFeedbackWithAccountInfoRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetFeedbackWithAccountInfoRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["feedbackType"] = this.feedbackType;
        data["accountId"] = this.accountId;
        data["completedOnly"] = this.completedOnly;
        data["incompleteOnly"] = this.incompleteOnly;
        data["accountEmail"] = this.accountEmail;
        return data;
    }
}

export interface IGetFeedbackWithAccountInfoRequest {
    feedbackType?: string | undefined;
    accountId?: string | undefined;
    completedOnly?: boolean;
    incompleteOnly?: boolean;
    accountEmail?: string | undefined;
}

export class GetFeedbackWithAccountInfoResponse implements IGetFeedbackWithAccountInfoResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;
    feedbackWithAccounts?: FeedbackWithAccount[] | undefined;

    constructor(data?: IGetFeedbackWithAccountInfoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.correlationId = _data["correlationId"];
            this.stackTrace = _data["stackTrace"];
            this.accountId = _data["accountId"];
            this.isPartial = _data["isPartial"];
            this.processingStage = _data["processingStage"];
            this.messageId = _data["messageId"];
            if (Array.isArray(_data["feedbackWithAccounts"])) {
                this.feedbackWithAccounts = [] as any;
                for (let item of _data["feedbackWithAccounts"])
                    this.feedbackWithAccounts!.push(FeedbackWithAccount.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetFeedbackWithAccountInfoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetFeedbackWithAccountInfoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["correlationId"] = this.correlationId;
        data["stackTrace"] = this.stackTrace;
        data["accountId"] = this.accountId;
        data["isPartial"] = this.isPartial;
        data["processingStage"] = this.processingStage;
        data["messageId"] = this.messageId;
        if (Array.isArray(this.feedbackWithAccounts)) {
            data["feedbackWithAccounts"] = [];
            for (let item of this.feedbackWithAccounts)
                data["feedbackWithAccounts"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetFeedbackWithAccountInfoResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;
    feedbackWithAccounts?: FeedbackWithAccount[] | undefined;
}

export class GetGuidelineFileUploadUrlRequest implements IGetGuidelineFileUploadUrlRequest {
    fileName?: string | undefined;
    contentType?: string | undefined;

    constructor(data?: IGetGuidelineFileUploadUrlRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileName = _data["fileName"];
            this.contentType = _data["contentType"];
        }
    }

    static fromJS(data: any): GetGuidelineFileUploadUrlRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetGuidelineFileUploadUrlRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["contentType"] = this.contentType;
        return data;
    }
}

export interface IGetGuidelineFileUploadUrlRequest {
    fileName?: string | undefined;
    contentType?: string | undefined;
}

export class GetGuidelineFileUploadUrlResponse implements IGetGuidelineFileUploadUrlResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;
    signedUrl?: string | undefined;
    objectName?: string | undefined;
    expiresAt?: Date | undefined;

    constructor(data?: IGetGuidelineFileUploadUrlResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.correlationId = _data["correlationId"];
            this.stackTrace = _data["stackTrace"];
            this.accountId = _data["accountId"];
            this.isPartial = _data["isPartial"];
            this.processingStage = _data["processingStage"];
            this.messageId = _data["messageId"];
            this.signedUrl = _data["signedUrl"];
            this.objectName = _data["objectName"];
            this.expiresAt = _data["expiresAt"] ? new Date(_data["expiresAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetGuidelineFileUploadUrlResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetGuidelineFileUploadUrlResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["correlationId"] = this.correlationId;
        data["stackTrace"] = this.stackTrace;
        data["accountId"] = this.accountId;
        data["isPartial"] = this.isPartial;
        data["processingStage"] = this.processingStage;
        data["messageId"] = this.messageId;
        data["signedUrl"] = this.signedUrl;
        data["objectName"] = this.objectName;
        data["expiresAt"] = this.expiresAt ? this.expiresAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IGetGuidelineFileUploadUrlResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;
    signedUrl?: string | undefined;
    objectName?: string | undefined;
    expiresAt?: Date | undefined;
}

export class GetGuidelineFileViewUrlRequest implements IGetGuidelineFileViewUrlRequest {
    openAiFileId?: string | undefined;
    objectName?: string | undefined;

    constructor(data?: IGetGuidelineFileViewUrlRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.openAiFileId = _data["openAiFileId"];
            this.objectName = _data["objectName"];
        }
    }

    static fromJS(data: any): GetGuidelineFileViewUrlRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetGuidelineFileViewUrlRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["openAiFileId"] = this.openAiFileId;
        data["objectName"] = this.objectName;
        return data;
    }
}

export interface IGetGuidelineFileViewUrlRequest {
    openAiFileId?: string | undefined;
    objectName?: string | undefined;
}

export class GetGuidelineFileViewUrlResponse implements IGetGuidelineFileViewUrlResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;
    signedUrl?: string | undefined;
    expiresAt?: Date | undefined;
    fileName?: string | undefined;
    contentType?: string | undefined;

    constructor(data?: IGetGuidelineFileViewUrlResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.correlationId = _data["correlationId"];
            this.stackTrace = _data["stackTrace"];
            this.accountId = _data["accountId"];
            this.isPartial = _data["isPartial"];
            this.processingStage = _data["processingStage"];
            this.messageId = _data["messageId"];
            this.signedUrl = _data["signedUrl"];
            this.expiresAt = _data["expiresAt"] ? new Date(_data["expiresAt"].toString()) : <any>undefined;
            this.fileName = _data["fileName"];
            this.contentType = _data["contentType"];
        }
    }

    static fromJS(data: any): GetGuidelineFileViewUrlResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetGuidelineFileViewUrlResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["correlationId"] = this.correlationId;
        data["stackTrace"] = this.stackTrace;
        data["accountId"] = this.accountId;
        data["isPartial"] = this.isPartial;
        data["processingStage"] = this.processingStage;
        data["messageId"] = this.messageId;
        data["signedUrl"] = this.signedUrl;
        data["expiresAt"] = this.expiresAt ? this.expiresAt.toISOString() : <any>undefined;
        data["fileName"] = this.fileName;
        data["contentType"] = this.contentType;
        return data;
    }
}

export interface IGetGuidelineFileViewUrlResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;
    signedUrl?: string | undefined;
    expiresAt?: Date | undefined;
    fileName?: string | undefined;
    contentType?: string | undefined;
}

export class GetGuidelineFilesRequest implements IGetGuidelineFilesRequest {

    constructor(data?: IGetGuidelineFilesRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): GetGuidelineFilesRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetGuidelineFilesRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IGetGuidelineFilesRequest {
}

export class GetGuidelineFilesResponse implements IGetGuidelineFilesResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;
    files?: OpenAiFile[] | undefined;

    constructor(data?: IGetGuidelineFilesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.correlationId = _data["correlationId"];
            this.stackTrace = _data["stackTrace"];
            this.accountId = _data["accountId"];
            this.isPartial = _data["isPartial"];
            this.processingStage = _data["processingStage"];
            this.messageId = _data["messageId"];
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(OpenAiFile.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetGuidelineFilesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetGuidelineFilesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["correlationId"] = this.correlationId;
        data["stackTrace"] = this.stackTrace;
        data["accountId"] = this.accountId;
        data["isPartial"] = this.isPartial;
        data["processingStage"] = this.processingStage;
        data["messageId"] = this.messageId;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetGuidelineFilesResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;
    files?: OpenAiFile[] | undefined;
}

export class GetInstantAlternativesRequest implements IGetInstantAlternativesRequest {
    originalPhrase!: string;
    componentId?: string | undefined;
    localDateKey!: string;

    constructor(data?: IGetInstantAlternativesRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.originalPhrase = _data["originalPhrase"];
            this.componentId = _data["componentId"];
            this.localDateKey = _data["localDateKey"];
        }
    }

    static fromJS(data: any): GetInstantAlternativesRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetInstantAlternativesRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["originalPhrase"] = this.originalPhrase;
        data["componentId"] = this.componentId;
        data["localDateKey"] = this.localDateKey;
        return data;
    }
}

export interface IGetInstantAlternativesRequest {
    originalPhrase: string;
    componentId?: string | undefined;
    localDateKey: string;
}

export class GetInstantAlternativesResponse implements IGetInstantAlternativesResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;
    originalPhrase?: string | undefined;
    componentId?: string | undefined;
    alternatives?: ComponentMatch[] | undefined;
    searchMethod?: string | undefined;

    constructor(data?: IGetInstantAlternativesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.correlationId = _data["correlationId"];
            this.stackTrace = _data["stackTrace"];
            this.accountId = _data["accountId"];
            this.isPartial = _data["isPartial"];
            this.processingStage = _data["processingStage"];
            this.messageId = _data["messageId"];
            this.originalPhrase = _data["originalPhrase"];
            this.componentId = _data["componentId"];
            if (Array.isArray(_data["alternatives"])) {
                this.alternatives = [] as any;
                for (let item of _data["alternatives"])
                    this.alternatives!.push(ComponentMatch.fromJS(item));
            }
            this.searchMethod = _data["searchMethod"];
        }
    }

    static fromJS(data: any): GetInstantAlternativesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetInstantAlternativesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["correlationId"] = this.correlationId;
        data["stackTrace"] = this.stackTrace;
        data["accountId"] = this.accountId;
        data["isPartial"] = this.isPartial;
        data["processingStage"] = this.processingStage;
        data["messageId"] = this.messageId;
        data["originalPhrase"] = this.originalPhrase;
        data["componentId"] = this.componentId;
        if (Array.isArray(this.alternatives)) {
            data["alternatives"] = [];
            for (let item of this.alternatives)
                data["alternatives"].push(item.toJSON());
        }
        data["searchMethod"] = this.searchMethod;
        return data;
    }
}

export interface IGetInstantAlternativesResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;
    originalPhrase?: string | undefined;
    componentId?: string | undefined;
    alternatives?: ComponentMatch[] | undefined;
    searchMethod?: string | undefined;
}

export class GetProfileAndTargetsRequest implements IGetProfileAndTargetsRequest {
    localDateKey?: string | undefined;

    constructor(data?: IGetProfileAndTargetsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.localDateKey = _data["localDateKey"];
        }
    }

    static fromJS(data: any): GetProfileAndTargetsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetProfileAndTargetsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["localDateKey"] = this.localDateKey;
        return data;
    }
}

export interface IGetProfileAndTargetsRequest {
    localDateKey?: string | undefined;
}

export class GetProfileAndTargetsResponse implements IGetProfileAndTargetsResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;
    age?: number | undefined;
    sex?: string | undefined;
    heightFeet?: number | undefined;
    heightInches?: number | undefined;
    weightLbs?: number | undefined;
    activityLevel?: string | undefined;
    baseCalories?: number | undefined;
    hasTargets?: boolean;
    goals?: string[] | undefined;
    goalSummary?: string | undefined;
    nutrientTargets?: NutrientTarget[] | undefined;

    constructor(data?: IGetProfileAndTargetsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.correlationId = _data["correlationId"];
            this.stackTrace = _data["stackTrace"];
            this.accountId = _data["accountId"];
            this.isPartial = _data["isPartial"];
            this.processingStage = _data["processingStage"];
            this.messageId = _data["messageId"];
            this.age = _data["age"];
            this.sex = _data["sex"];
            this.heightFeet = _data["heightFeet"];
            this.heightInches = _data["heightInches"];
            this.weightLbs = _data["weightLbs"];
            this.activityLevel = _data["activityLevel"];
            this.baseCalories = _data["baseCalories"];
            this.hasTargets = _data["hasTargets"];
            if (Array.isArray(_data["goals"])) {
                this.goals = [] as any;
                for (let item of _data["goals"])
                    this.goals!.push(item);
            }
            this.goalSummary = _data["goalSummary"];
            if (Array.isArray(_data["nutrientTargets"])) {
                this.nutrientTargets = [] as any;
                for (let item of _data["nutrientTargets"])
                    this.nutrientTargets!.push(NutrientTarget.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetProfileAndTargetsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetProfileAndTargetsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["correlationId"] = this.correlationId;
        data["stackTrace"] = this.stackTrace;
        data["accountId"] = this.accountId;
        data["isPartial"] = this.isPartial;
        data["processingStage"] = this.processingStage;
        data["messageId"] = this.messageId;
        data["age"] = this.age;
        data["sex"] = this.sex;
        data["heightFeet"] = this.heightFeet;
        data["heightInches"] = this.heightInches;
        data["weightLbs"] = this.weightLbs;
        data["activityLevel"] = this.activityLevel;
        data["baseCalories"] = this.baseCalories;
        data["hasTargets"] = this.hasTargets;
        if (Array.isArray(this.goals)) {
            data["goals"] = [];
            for (let item of this.goals)
                data["goals"].push(item);
        }
        data["goalSummary"] = this.goalSummary;
        if (Array.isArray(this.nutrientTargets)) {
            data["nutrientTargets"] = [];
            for (let item of this.nutrientTargets)
                data["nutrientTargets"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetProfileAndTargetsResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;
    age?: number | undefined;
    sex?: string | undefined;
    heightFeet?: number | undefined;
    heightInches?: number | undefined;
    weightLbs?: number | undefined;
    activityLevel?: string | undefined;
    baseCalories?: number | undefined;
    hasTargets?: boolean;
    goals?: string[] | undefined;
    goalSummary?: string | undefined;
    nutrientTargets?: NutrientTarget[] | undefined;
}

export class GetSharedMealRequest implements IGetSharedMealRequest {
    shareToken?: string | undefined;
    localDateKey?: string | undefined;

    constructor(data?: IGetSharedMealRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.shareToken = _data["shareToken"];
            this.localDateKey = _data["localDateKey"];
        }
    }

    static fromJS(data: any): GetSharedMealRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetSharedMealRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shareToken"] = this.shareToken;
        data["localDateKey"] = this.localDateKey;
        return data;
    }
}

export interface IGetSharedMealRequest {
    shareToken?: string | undefined;
    localDateKey?: string | undefined;
}

export class GetSharedMealResponse implements IGetSharedMealResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;
    mealData?: MealSelection;
    sharedByAccountId?: string | undefined;
    isExpired?: boolean;

    constructor(data?: IGetSharedMealResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.correlationId = _data["correlationId"];
            this.stackTrace = _data["stackTrace"];
            this.accountId = _data["accountId"];
            this.isPartial = _data["isPartial"];
            this.processingStage = _data["processingStage"];
            this.messageId = _data["messageId"];
            this.mealData = _data["mealData"] ? MealSelection.fromJS(_data["mealData"]) : <any>undefined;
            this.sharedByAccountId = _data["sharedByAccountId"];
            this.isExpired = _data["isExpired"];
        }
    }

    static fromJS(data: any): GetSharedMealResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetSharedMealResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["correlationId"] = this.correlationId;
        data["stackTrace"] = this.stackTrace;
        data["accountId"] = this.accountId;
        data["isPartial"] = this.isPartial;
        data["processingStage"] = this.processingStage;
        data["messageId"] = this.messageId;
        data["mealData"] = this.mealData ? this.mealData.toJSON() : <any>undefined;
        data["sharedByAccountId"] = this.sharedByAccountId;
        data["isExpired"] = this.isExpired;
        return data;
    }
}

export interface IGetSharedMealResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;
    mealData?: MealSelection;
    sharedByAccountId?: string | undefined;
    isExpired?: boolean;
}

export class GetUserChatMessagesRequest implements IGetUserChatMessagesRequest {
    accountId?: string | undefined;
    localDateKey?: string | undefined;
    limit?: number | undefined;

    constructor(data?: IGetUserChatMessagesRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountId = _data["accountId"];
            this.localDateKey = _data["localDateKey"];
            this.limit = _data["limit"];
        }
    }

    static fromJS(data: any): GetUserChatMessagesRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserChatMessagesRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountId"] = this.accountId;
        data["localDateKey"] = this.localDateKey;
        data["limit"] = this.limit;
        return data;
    }
}

export interface IGetUserChatMessagesRequest {
    accountId?: string | undefined;
    localDateKey?: string | undefined;
    limit?: number | undefined;
}

export class GetUserChatMessagesResponse implements IGetUserChatMessagesResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;
    messages?: ChatMessage[] | undefined;
    accountId?: string | undefined;
    accountEmail?: string | undefined;

    constructor(data?: IGetUserChatMessagesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.correlationId = _data["correlationId"];
            this.stackTrace = _data["stackTrace"];
            this.isPartial = _data["isPartial"];
            this.processingStage = _data["processingStage"];
            this.messageId = _data["messageId"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ChatMessage.fromJS(item));
            }
            this.accountId = _data["accountId"];
            this.accountEmail = _data["accountEmail"];
        }
    }

    static fromJS(data: any): GetUserChatMessagesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserChatMessagesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["correlationId"] = this.correlationId;
        data["stackTrace"] = this.stackTrace;
        data["isPartial"] = this.isPartial;
        data["processingStage"] = this.processingStage;
        data["messageId"] = this.messageId;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        data["accountId"] = this.accountId;
        data["accountEmail"] = this.accountEmail;
        return data;
    }
}

export interface IGetUserChatMessagesResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;
    messages?: ChatMessage[] | undefined;
    accountId?: string | undefined;
    accountEmail?: string | undefined;
}

export class HydrateAlternateSelectionRequest implements IHydrateAlternateSelectionRequest {
    componentId!: string;
    selectedMatch!: ComponentMatch;
    localDateKey!: string;
    messageId?: string | undefined;
    foodEntryId?: string | undefined;

    constructor(data?: IHydrateAlternateSelectionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.selectedMatch = new ComponentMatch();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.componentId = _data["componentId"];
            this.selectedMatch = _data["selectedMatch"] ? ComponentMatch.fromJS(_data["selectedMatch"]) : new ComponentMatch();
            this.localDateKey = _data["localDateKey"];
            this.messageId = _data["messageId"];
            this.foodEntryId = _data["foodEntryId"];
        }
    }

    static fromJS(data: any): HydrateAlternateSelectionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new HydrateAlternateSelectionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["componentId"] = this.componentId;
        data["selectedMatch"] = this.selectedMatch ? this.selectedMatch.toJSON() : <any>undefined;
        data["localDateKey"] = this.localDateKey;
        data["messageId"] = this.messageId;
        data["foodEntryId"] = this.foodEntryId;
        return data;
    }
}

export interface IHydrateAlternateSelectionRequest {
    componentId: string;
    selectedMatch: ComponentMatch;
    localDateKey: string;
    messageId?: string | undefined;
    foodEntryId?: string | undefined;
}

export class LearnMoreAboutRequest implements ILearnMoreAboutRequest {
    topic?: string | undefined;
    localDateKey?: string | undefined;

    constructor(data?: ILearnMoreAboutRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.topic = _data["topic"];
            this.localDateKey = _data["localDateKey"];
        }
    }

    static fromJS(data: any): LearnMoreAboutRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LearnMoreAboutRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["topic"] = this.topic;
        data["localDateKey"] = this.localDateKey;
        return data;
    }
}

export interface ILearnMoreAboutRequest {
    topic?: string | undefined;
    localDateKey?: string | undefined;
}

export class LogEntryDto implements ILogEntryDto {
    timestampUtc?: Date;
    severity?: string | undefined;
    message?: string | undefined;
    accountId?: string | undefined;
    email?: string | undefined;
    traceId?: string | undefined;
    sourceService?: string | undefined;
    extra?: { [key: string]: string; } | undefined;

    constructor(data?: ILogEntryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timestampUtc = _data["timestampUtc"] ? new Date(_data["timestampUtc"].toString()) : <any>undefined;
            this.severity = _data["severity"];
            this.message = _data["message"];
            this.accountId = _data["accountId"];
            this.email = _data["email"];
            this.traceId = _data["traceId"];
            this.sourceService = _data["sourceService"];
            if (_data["extra"]) {
                this.extra = {} as any;
                for (let key in _data["extra"]) {
                    if (_data["extra"].hasOwnProperty(key))
                        (<any>this.extra)![key] = _data["extra"][key];
                }
            }
        }
    }

    static fromJS(data: any): LogEntryDto {
        data = typeof data === 'object' ? data : {};
        let result = new LogEntryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timestampUtc"] = this.timestampUtc ? this.timestampUtc.toISOString() : <any>undefined;
        data["severity"] = this.severity;
        data["message"] = this.message;
        data["accountId"] = this.accountId;
        data["email"] = this.email;
        data["traceId"] = this.traceId;
        data["sourceService"] = this.sourceService;
        if (this.extra) {
            data["extra"] = {};
            for (let key in this.extra) {
                if (this.extra.hasOwnProperty(key))
                    (<any>data["extra"])[key] = (<any>this.extra)[key];
            }
        }
        return data;
    }
}

export interface ILogEntryDto {
    timestampUtc?: Date;
    severity?: string | undefined;
    message?: string | undefined;
    accountId?: string | undefined;
    email?: string | undefined;
    traceId?: string | undefined;
    sourceService?: string | undefined;
    extra?: { [key: string]: string; } | undefined;
}

export class MealPreview implements IMealPreview {
    mealName?: string | undefined;
    foods?: FoodPreview[] | undefined;

    constructor(data?: IMealPreview) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mealName = _data["mealName"];
            if (Array.isArray(_data["foods"])) {
                this.foods = [] as any;
                for (let item of _data["foods"])
                    this.foods!.push(FoodPreview.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MealPreview {
        data = typeof data === 'object' ? data : {};
        let result = new MealPreview();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mealName"] = this.mealName;
        if (Array.isArray(this.foods)) {
            data["foods"] = [];
            for (let item of this.foods)
                data["foods"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMealPreview {
    mealName?: string | undefined;
    foods?: FoodPreview[] | undefined;
}

export class MealSelection implements IMealSelection {
    mealName?: string | undefined;
    pendingMessageId?: string | undefined;
    foods?: Food[] | undefined;
    foodEntryId?: string | undefined;
    foodId?: string | undefined;
    componentId?: string | undefined;
    sharedById?: string | undefined;
    isPending?: boolean;

    constructor(data?: IMealSelection) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mealName = _data["mealName"];
            this.pendingMessageId = _data["pendingMessageId"];
            if (Array.isArray(_data["foods"])) {
                this.foods = [] as any;
                for (let item of _data["foods"])
                    this.foods!.push(Food.fromJS(item));
            }
            this.foodEntryId = _data["foodEntryId"];
            this.foodId = _data["foodId"];
            this.componentId = _data["componentId"];
            this.sharedById = _data["sharedById"];
            this.isPending = _data["isPending"];
        }
    }

    static fromJS(data: any): MealSelection {
        data = typeof data === 'object' ? data : {};
        let result = new MealSelection();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mealName"] = this.mealName;
        data["pendingMessageId"] = this.pendingMessageId;
        if (Array.isArray(this.foods)) {
            data["foods"] = [];
            for (let item of this.foods)
                data["foods"].push(item.toJSON());
        }
        data["foodEntryId"] = this.foodEntryId;
        data["foodId"] = this.foodId;
        data["componentId"] = this.componentId;
        data["sharedById"] = this.sharedById;
        data["isPending"] = this.isPending;
        return data;
    }
}

export interface IMealSelection {
    mealName?: string | undefined;
    pendingMessageId?: string | undefined;
    foods?: Food[] | undefined;
    foodEntryId?: string | undefined;
    foodId?: string | undefined;
    componentId?: string | undefined;
    sharedById?: string | undefined;
    isPending?: boolean;
}

export enum MessageRoleTypes {
    User = "User",
    Assistant = "Assistant",
    Tool = "Tool",
    System = "System",
    ContextNote = "ContextNote",
    PendingFoodSelection = "PendingFoodSelection",
    CompletedFoodSelection = "CompletedFoodSelection",
    CanceledFoodSelection = "CanceledFoodSelection",
    PendingEditFoodSelection = "PendingEditFoodSelection",
    CompletedEditFoodSelection = "CompletedEditFoodSelection",
}

export class NutrientBreakdown implements INutrientBreakdown {
    nutrientKey?: string | undefined;
    nutrientName?: string | undefined;
    unit?: string | undefined;
    totalAmount?: number;
    minTarget?: number | undefined;
    maxTarget?: number | undefined;
    isGoal?: boolean;
    sortOrder?: number;
    readonly percentOfTarget?: number | undefined;
    foods?: FoodContribution[] | undefined;

    constructor(data?: INutrientBreakdown) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nutrientKey = _data["nutrientKey"];
            this.nutrientName = _data["nutrientName"];
            this.unit = _data["unit"];
            this.totalAmount = _data["totalAmount"];
            this.minTarget = _data["minTarget"];
            this.maxTarget = _data["maxTarget"];
            this.isGoal = _data["isGoal"];
            this.sortOrder = _data["sortOrder"];
            (<any>this).percentOfTarget = _data["percentOfTarget"];
            if (Array.isArray(_data["foods"])) {
                this.foods = [] as any;
                for (let item of _data["foods"])
                    this.foods!.push(FoodContribution.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NutrientBreakdown {
        data = typeof data === 'object' ? data : {};
        let result = new NutrientBreakdown();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nutrientKey"] = this.nutrientKey;
        data["nutrientName"] = this.nutrientName;
        data["unit"] = this.unit;
        data["totalAmount"] = this.totalAmount;
        data["minTarget"] = this.minTarget;
        data["maxTarget"] = this.maxTarget;
        data["isGoal"] = this.isGoal;
        data["sortOrder"] = this.sortOrder;
        data["percentOfTarget"] = this.percentOfTarget;
        if (Array.isArray(this.foods)) {
            data["foods"] = [];
            for (let item of this.foods)
                data["foods"].push(item.toJSON());
        }
        return data;
    }
}

export interface INutrientBreakdown {
    nutrientKey?: string | undefined;
    nutrientName?: string | undefined;
    unit?: string | undefined;
    totalAmount?: number;
    minTarget?: number | undefined;
    maxTarget?: number | undefined;
    isGoal?: boolean;
    sortOrder?: number;
    percentOfTarget?: number | undefined;
    foods?: FoodContribution[] | undefined;
}

export class NutrientContribution implements INutrientContribution {
    nutrientKey?: string | undefined;
    nutrientName?: string | undefined;
    name?: string | undefined;
    brandName?: string | undefined;
    amount?: number;
    unit?: string | undefined;
    originalUnit?: string | undefined;

    constructor(data?: INutrientContribution) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nutrientKey = _data["nutrientKey"];
            this.nutrientName = _data["nutrientName"];
            this.name = _data["name"];
            this.brandName = _data["brandName"];
            this.amount = _data["amount"];
            this.unit = _data["unit"];
            this.originalUnit = _data["originalUnit"];
        }
    }

    static fromJS(data: any): NutrientContribution {
        data = typeof data === 'object' ? data : {};
        let result = new NutrientContribution();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nutrientKey"] = this.nutrientKey;
        data["nutrientName"] = this.nutrientName;
        data["name"] = this.name;
        data["brandName"] = this.brandName;
        data["amount"] = this.amount;
        data["unit"] = this.unit;
        data["originalUnit"] = this.originalUnit;
        return data;
    }
}

export interface INutrientContribution {
    nutrientKey?: string | undefined;
    nutrientName?: string | undefined;
    name?: string | undefined;
    brandName?: string | undefined;
    amount?: number;
    unit?: string | undefined;
    originalUnit?: string | undefined;
}

export class NutrientTarget implements INutrientTarget {
    nutrientKey?: string | undefined;
    maxValue?: number | undefined;
    minValue?: number | undefined;
    isDefault?: boolean;
    isGoal?: boolean;

    constructor(data?: INutrientTarget) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nutrientKey = _data["nutrientKey"];
            this.maxValue = _data["maxValue"];
            this.minValue = _data["minValue"];
            this.isDefault = _data["isDefault"];
            this.isGoal = _data["isGoal"];
        }
    }

    static fromJS(data: any): NutrientTarget {
        data = typeof data === 'object' ? data : {};
        let result = new NutrientTarget();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nutrientKey"] = this.nutrientKey;
        data["maxValue"] = this.maxValue;
        data["minValue"] = this.minValue;
        data["isDefault"] = this.isDefault;
        data["isGoal"] = this.isGoal;
        return data;
    }
}

export interface INutrientTarget {
    nutrientKey?: string | undefined;
    maxValue?: number | undefined;
    minValue?: number | undefined;
    isDefault?: boolean;
    isGoal?: boolean;
}

export class OpenAiFile implements IOpenAiFile {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    type?: string | undefined;
    openAiFileId?: string | undefined;
    vectorStoreId?: string | undefined;
    fileName?: string | undefined;
    fileSize?: number;
    contentType?: string | undefined;
    fileSha256Hash?: string | undefined;
    uploadedByAccountId?: string | undefined;
    status?: string | undefined;
    errorMessage?: string | undefined;
    cloudStorageObjectName?: string | undefined;

    constructor(data?: IOpenAiFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdDateUtc = _data["createdDateUtc"] ? new Date(_data["createdDateUtc"].toString()) : <any>undefined;
            this.lastUpdatedDateUtc = _data["lastUpdatedDateUtc"] ? new Date(_data["lastUpdatedDateUtc"].toString()) : <any>undefined;
            this.type = _data["type"];
            this.openAiFileId = _data["openAiFileId"];
            this.vectorStoreId = _data["vectorStoreId"];
            this.fileName = _data["fileName"];
            this.fileSize = _data["fileSize"];
            this.contentType = _data["contentType"];
            this.fileSha256Hash = _data["fileSha256Hash"];
            this.uploadedByAccountId = _data["uploadedByAccountId"];
            this.status = _data["status"];
            this.errorMessage = _data["errorMessage"];
            this.cloudStorageObjectName = _data["cloudStorageObjectName"];
        }
    }

    static fromJS(data: any): OpenAiFile {
        data = typeof data === 'object' ? data : {};
        let result = new OpenAiFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdDateUtc"] = this.createdDateUtc ? this.createdDateUtc.toISOString() : <any>undefined;
        data["lastUpdatedDateUtc"] = this.lastUpdatedDateUtc ? this.lastUpdatedDateUtc.toISOString() : <any>undefined;
        data["type"] = this.type;
        data["openAiFileId"] = this.openAiFileId;
        data["vectorStoreId"] = this.vectorStoreId;
        data["fileName"] = this.fileName;
        data["fileSize"] = this.fileSize;
        data["contentType"] = this.contentType;
        data["fileSha256Hash"] = this.fileSha256Hash;
        data["uploadedByAccountId"] = this.uploadedByAccountId;
        data["status"] = this.status;
        data["errorMessage"] = this.errorMessage;
        data["cloudStorageObjectName"] = this.cloudStorageObjectName;
        return data;
    }
}

export interface IOpenAiFile {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    type?: string | undefined;
    openAiFileId?: string | undefined;
    vectorStoreId?: string | undefined;
    fileName?: string | undefined;
    fileSize?: number;
    contentType?: string | undefined;
    fileSha256Hash?: string | undefined;
    uploadedByAccountId?: string | undefined;
    status?: string | undefined;
    errorMessage?: string | undefined;
    cloudStorageObjectName?: string | undefined;
}

export class RegisterAccountRequest implements IRegisterAccountRequest {
    email?: string | undefined;
    timeZoneId?: string | undefined;
    isAnonymous?: boolean;

    constructor(data?: IRegisterAccountRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.timeZoneId = _data["timeZoneId"];
            this.isAnonymous = _data["isAnonymous"];
        }
    }

    static fromJS(data: any): RegisterAccountRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterAccountRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["timeZoneId"] = this.timeZoneId;
        data["isAnonymous"] = this.isAnonymous;
        return data;
    }
}

export interface IRegisterAccountRequest {
    email?: string | undefined;
    timeZoneId?: string | undefined;
    isAnonymous?: boolean;
}

export class RelogFavoriteRequest implements IRelogFavoriteRequest {
    favoriteId!: string;
    localDateKey?: string | undefined;
    mealName?: string | undefined;

    constructor(data?: IRelogFavoriteRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.favoriteId = _data["favoriteId"];
            this.localDateKey = _data["localDateKey"];
            this.mealName = _data["mealName"];
        }
    }

    static fromJS(data: any): RelogFavoriteRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RelogFavoriteRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["favoriteId"] = this.favoriteId;
        data["localDateKey"] = this.localDateKey;
        data["mealName"] = this.mealName;
        return data;
    }
}

export interface IRelogFavoriteRequest {
    favoriteId: string;
    localDateKey?: string | undefined;
    mealName?: string | undefined;
}

export class RelogFavoriteResponse implements IRelogFavoriteResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    food?: Food;
    messageId?: string | undefined;

    constructor(data?: IRelogFavoriteResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.correlationId = _data["correlationId"];
            this.stackTrace = _data["stackTrace"];
            this.accountId = _data["accountId"];
            this.isPartial = _data["isPartial"];
            this.processingStage = _data["processingStage"];
            this.food = _data["food"] ? Food.fromJS(_data["food"]) : <any>undefined;
            this.messageId = _data["messageId"];
        }
    }

    static fromJS(data: any): RelogFavoriteResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RelogFavoriteResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["correlationId"] = this.correlationId;
        data["stackTrace"] = this.stackTrace;
        data["accountId"] = this.accountId;
        data["isPartial"] = this.isPartial;
        data["processingStage"] = this.processingStage;
        data["food"] = this.food ? this.food.toJSON() : <any>undefined;
        data["messageId"] = this.messageId;
        return data;
    }
}

export interface IRelogFavoriteResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    food?: Food;
    messageId?: string | undefined;
}

export class RemoveFavoriteRequest implements IRemoveFavoriteRequest {
    favoriteId!: string;

    constructor(data?: IRemoveFavoriteRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.favoriteId = _data["favoriteId"];
        }
    }

    static fromJS(data: any): RemoveFavoriteRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RemoveFavoriteRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["favoriteId"] = this.favoriteId;
        return data;
    }
}

export interface IRemoveFavoriteRequest {
    favoriteId: string;
}

export class RemoveFavoriteResponse implements IRemoveFavoriteResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;

    constructor(data?: IRemoveFavoriteResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.correlationId = _data["correlationId"];
            this.stackTrace = _data["stackTrace"];
            this.accountId = _data["accountId"];
            this.isPartial = _data["isPartial"];
            this.processingStage = _data["processingStage"];
            this.messageId = _data["messageId"];
        }
    }

    static fromJS(data: any): RemoveFavoriteResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RemoveFavoriteResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["correlationId"] = this.correlationId;
        data["stackTrace"] = this.stackTrace;
        data["accountId"] = this.accountId;
        data["isPartial"] = this.isPartial;
        data["processingStage"] = this.processingStage;
        data["messageId"] = this.messageId;
        return data;
    }
}

export interface IRemoveFavoriteResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;
}

export class Request implements IRequest {

    constructor(data?: IRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): Request {
        data = typeof data === 'object' ? data : {};
        let result = new Request();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IRequest {
}

export class Response implements IResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;

    constructor(data?: IResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.correlationId = _data["correlationId"];
            this.stackTrace = _data["stackTrace"];
            this.accountId = _data["accountId"];
            this.isPartial = _data["isPartial"];
            this.processingStage = _data["processingStage"];
            this.messageId = _data["messageId"];
        }
    }

    static fromJS(data: any): Response {
        data = typeof data === 'object' ? data : {};
        let result = new Response();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["correlationId"] = this.correlationId;
        data["stackTrace"] = this.stackTrace;
        data["accountId"] = this.accountId;
        data["isPartial"] = this.isPartial;
        data["processingStage"] = this.processingStage;
        data["messageId"] = this.messageId;
        return data;
    }
}

export interface IResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;
}

export class RunChatRequest implements IRunChatRequest {
    message?: string | undefined;
    localDateKey?: string | undefined;
    retryCount?: number | undefined;

    constructor(data?: IRunChatRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.localDateKey = _data["localDateKey"];
            this.retryCount = _data["retryCount"];
        }
    }

    static fromJS(data: any): RunChatRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RunChatRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["localDateKey"] = this.localDateKey;
        data["retryCount"] = this.retryCount;
        return data;
    }
}

export interface IRunChatRequest {
    message?: string | undefined;
    localDateKey?: string | undefined;
    retryCount?: number | undefined;
}

export class SearchFoodPhraseRequest implements ISearchFoodPhraseRequest {
    searchPhrase?: string | undefined;
    localDateKey?: string | undefined;
    originalPhrase?: string | undefined;
    messageId?: string | undefined;
    componentId?: string | undefined;
    foodEntryId?: string | undefined;
    parentFoodName?: string | undefined;
    parentFoodSingularUnit?: string | undefined;
    parentFoodPluralUnit?: string | undefined;
    existingComponents?: ComponentDescription[] | undefined;

    constructor(data?: ISearchFoodPhraseRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.searchPhrase = _data["searchPhrase"];
            this.localDateKey = _data["localDateKey"];
            this.originalPhrase = _data["originalPhrase"];
            this.messageId = _data["messageId"];
            this.componentId = _data["componentId"];
            this.foodEntryId = _data["foodEntryId"];
            this.parentFoodName = _data["parentFoodName"];
            this.parentFoodSingularUnit = _data["parentFoodSingularUnit"];
            this.parentFoodPluralUnit = _data["parentFoodPluralUnit"];
            if (Array.isArray(_data["existingComponents"])) {
                this.existingComponents = [] as any;
                for (let item of _data["existingComponents"])
                    this.existingComponents!.push(ComponentDescription.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SearchFoodPhraseRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SearchFoodPhraseRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchPhrase"] = this.searchPhrase;
        data["localDateKey"] = this.localDateKey;
        data["originalPhrase"] = this.originalPhrase;
        data["messageId"] = this.messageId;
        data["componentId"] = this.componentId;
        data["foodEntryId"] = this.foodEntryId;
        data["parentFoodName"] = this.parentFoodName;
        data["parentFoodSingularUnit"] = this.parentFoodSingularUnit;
        data["parentFoodPluralUnit"] = this.parentFoodPluralUnit;
        if (Array.isArray(this.existingComponents)) {
            data["existingComponents"] = [];
            for (let item of this.existingComponents)
                data["existingComponents"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISearchFoodPhraseRequest {
    searchPhrase?: string | undefined;
    localDateKey?: string | undefined;
    originalPhrase?: string | undefined;
    messageId?: string | undefined;
    componentId?: string | undefined;
    foodEntryId?: string | undefined;
    parentFoodName?: string | undefined;
    parentFoodSingularUnit?: string | undefined;
    parentFoodPluralUnit?: string | undefined;
    existingComponents?: ComponentDescription[] | undefined;
}

export class SearchFoodPhraseResponse implements ISearchFoodPhraseResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;
    searchPhrase?: string | undefined;
    foodOptions?: Food[] | undefined;

    constructor(data?: ISearchFoodPhraseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.correlationId = _data["correlationId"];
            this.stackTrace = _data["stackTrace"];
            this.accountId = _data["accountId"];
            this.isPartial = _data["isPartial"];
            this.processingStage = _data["processingStage"];
            this.messageId = _data["messageId"];
            this.searchPhrase = _data["searchPhrase"];
            if (Array.isArray(_data["foodOptions"])) {
                this.foodOptions = [] as any;
                for (let item of _data["foodOptions"])
                    this.foodOptions!.push(Food.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SearchFoodPhraseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SearchFoodPhraseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["correlationId"] = this.correlationId;
        data["stackTrace"] = this.stackTrace;
        data["accountId"] = this.accountId;
        data["isPartial"] = this.isPartial;
        data["processingStage"] = this.processingStage;
        data["messageId"] = this.messageId;
        data["searchPhrase"] = this.searchPhrase;
        if (Array.isArray(this.foodOptions)) {
            data["foodOptions"] = [];
            for (let item of this.foodOptions)
                data["foodOptions"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISearchFoodPhraseResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;
    searchPhrase?: string | undefined;
    foodOptions?: Food[] | undefined;
}

export class SearchLogsRequest implements ISearchLogsRequest {
    accountId?: string | undefined;
    email?: string | undefined;
    contains?: string | undefined;
    severity?: string | undefined;
    traceId?: string | undefined;
    minutesBack?: number | undefined;
    pageSize?: number | undefined;
    pageToken?: string | undefined;

    constructor(data?: ISearchLogsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountId = _data["accountId"];
            this.email = _data["email"];
            this.contains = _data["contains"];
            this.severity = _data["severity"];
            this.traceId = _data["traceId"];
            this.minutesBack = _data["minutesBack"];
            this.pageSize = _data["pageSize"];
            this.pageToken = _data["pageToken"];
        }
    }

    static fromJS(data: any): SearchLogsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SearchLogsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountId"] = this.accountId;
        data["email"] = this.email;
        data["contains"] = this.contains;
        data["severity"] = this.severity;
        data["traceId"] = this.traceId;
        data["minutesBack"] = this.minutesBack;
        data["pageSize"] = this.pageSize;
        data["pageToken"] = this.pageToken;
        return data;
    }
}

export interface ISearchLogsRequest {
    accountId?: string | undefined;
    email?: string | undefined;
    contains?: string | undefined;
    severity?: string | undefined;
    traceId?: string | undefined;
    minutesBack?: number | undefined;
    pageSize?: number | undefined;
    pageToken?: string | undefined;
}

export class SearchLogsResponse implements ISearchLogsResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;
    items?: LogEntryDto[] | undefined;
    nextPageToken?: string | undefined;

    constructor(data?: ISearchLogsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.correlationId = _data["correlationId"];
            this.stackTrace = _data["stackTrace"];
            this.accountId = _data["accountId"];
            this.isPartial = _data["isPartial"];
            this.processingStage = _data["processingStage"];
            this.messageId = _data["messageId"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LogEntryDto.fromJS(item));
            }
            this.nextPageToken = _data["nextPageToken"];
        }
    }

    static fromJS(data: any): SearchLogsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SearchLogsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["correlationId"] = this.correlationId;
        data["stackTrace"] = this.stackTrace;
        data["accountId"] = this.accountId;
        data["isPartial"] = this.isPartial;
        data["processingStage"] = this.processingStage;
        data["messageId"] = this.messageId;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["nextPageToken"] = this.nextPageToken;
        return data;
    }
}

export interface ISearchLogsResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;
    items?: LogEntryDto[] | undefined;
    nextPageToken?: string | undefined;
}

export class ServingIdentifier implements IServingIdentifier {
    provider?: string | undefined;
    foodType?: string | undefined;
    foodName?: string | undefined;
    variantIndex?: number;
    servingType?: string | undefined;

    constructor(data?: IServingIdentifier) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.provider = _data["provider"];
            this.foodType = _data["foodType"];
            this.foodName = _data["foodName"];
            this.variantIndex = _data["variantIndex"];
            this.servingType = _data["servingType"];
        }
    }

    static fromJS(data: any): ServingIdentifier {
        data = typeof data === 'object' ? data : {};
        let result = new ServingIdentifier();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["provider"] = this.provider;
        data["foodType"] = this.foodType;
        data["foodName"] = this.foodName;
        data["variantIndex"] = this.variantIndex;
        data["servingType"] = this.servingType;
        return data;
    }
}

export interface IServingIdentifier {
    provider?: string | undefined;
    foodType?: string | undefined;
    foodName?: string | undefined;
    variantIndex?: number;
    servingType?: string | undefined;
}

export class SetupGoalsRequest implements ISetupGoalsRequest {
    localDateKey?: string | undefined;
    isTweaking?: boolean;

    constructor(data?: ISetupGoalsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.localDateKey = _data["localDateKey"];
            this.isTweaking = _data["isTweaking"];
        }
    }

    static fromJS(data: any): SetupGoalsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SetupGoalsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["localDateKey"] = this.localDateKey;
        data["isTweaking"] = this.isTweaking;
        return data;
    }
}

export interface ISetupGoalsRequest {
    localDateKey?: string | undefined;
    isTweaking?: boolean;
}

export class SubmitEditServingSelectionRequest implements ISubmitEditServingSelectionRequest {
    pendingMessageId?: string | undefined;
    foodEntryId?: string | undefined;
    foodId?: string | undefined;
    componentId?: string | undefined;
    localDateKey?: string | undefined;
    selections?: UserSelectedServing[] | undefined;
    foodQuantities?: UserSelectedFoodQuantity[] | undefined;
    foods?: Food[] | undefined;
    mealName?: string | undefined;

    constructor(data?: ISubmitEditServingSelectionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pendingMessageId = _data["pendingMessageId"];
            this.foodEntryId = _data["foodEntryId"];
            this.foodId = _data["foodId"];
            this.componentId = _data["componentId"];
            this.localDateKey = _data["localDateKey"];
            if (Array.isArray(_data["selections"])) {
                this.selections = [] as any;
                for (let item of _data["selections"])
                    this.selections!.push(UserSelectedServing.fromJS(item));
            }
            if (Array.isArray(_data["foodQuantities"])) {
                this.foodQuantities = [] as any;
                for (let item of _data["foodQuantities"])
                    this.foodQuantities!.push(UserSelectedFoodQuantity.fromJS(item));
            }
            if (Array.isArray(_data["foods"])) {
                this.foods = [] as any;
                for (let item of _data["foods"])
                    this.foods!.push(Food.fromJS(item));
            }
            this.mealName = _data["mealName"];
        }
    }

    static fromJS(data: any): SubmitEditServingSelectionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitEditServingSelectionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pendingMessageId"] = this.pendingMessageId;
        data["foodEntryId"] = this.foodEntryId;
        data["foodId"] = this.foodId;
        data["componentId"] = this.componentId;
        data["localDateKey"] = this.localDateKey;
        if (Array.isArray(this.selections)) {
            data["selections"] = [];
            for (let item of this.selections)
                data["selections"].push(item.toJSON());
        }
        if (Array.isArray(this.foodQuantities)) {
            data["foodQuantities"] = [];
            for (let item of this.foodQuantities)
                data["foodQuantities"].push(item.toJSON());
        }
        if (Array.isArray(this.foods)) {
            data["foods"] = [];
            for (let item of this.foods)
                data["foods"].push(item.toJSON());
        }
        data["mealName"] = this.mealName;
        return data;
    }
}

export interface ISubmitEditServingSelectionRequest {
    pendingMessageId?: string | undefined;
    foodEntryId?: string | undefined;
    foodId?: string | undefined;
    componentId?: string | undefined;
    localDateKey?: string | undefined;
    selections?: UserSelectedServing[] | undefined;
    foodQuantities?: UserSelectedFoodQuantity[] | undefined;
    foods?: Food[] | undefined;
    mealName?: string | undefined;
}

export class SubmitServingSelectionRequest implements ISubmitServingSelectionRequest {
    localDateKey?: string | undefined;
    pendingMessageId?: string | undefined;
    selections?: UserSelectedServing[] | undefined;
    foodQuantities?: UserSelectedFoodQuantity[] | undefined;

    constructor(data?: ISubmitServingSelectionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.localDateKey = _data["localDateKey"];
            this.pendingMessageId = _data["pendingMessageId"];
            if (Array.isArray(_data["selections"])) {
                this.selections = [] as any;
                for (let item of _data["selections"])
                    this.selections!.push(UserSelectedServing.fromJS(item));
            }
            if (Array.isArray(_data["foodQuantities"])) {
                this.foodQuantities = [] as any;
                for (let item of _data["foodQuantities"])
                    this.foodQuantities!.push(UserSelectedFoodQuantity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SubmitServingSelectionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitServingSelectionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["localDateKey"] = this.localDateKey;
        data["pendingMessageId"] = this.pendingMessageId;
        if (Array.isArray(this.selections)) {
            data["selections"] = [];
            for (let item of this.selections)
                data["selections"].push(item.toJSON());
        }
        if (Array.isArray(this.foodQuantities)) {
            data["foodQuantities"] = [];
            for (let item of this.foodQuantities)
                data["foodQuantities"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISubmitServingSelectionRequest {
    localDateKey?: string | undefined;
    pendingMessageId?: string | undefined;
    selections?: UserSelectedServing[] | undefined;
    foodQuantities?: UserSelectedFoodQuantity[] | undefined;
}

export class TelemetryContext implements ITelemetryContext {
    buildStamp?: BuildStamp;
    environment?: string | undefined;
    userAgent?: string | undefined;
    extras?: { [key: string]: string; } | undefined;

    constructor(data?: ITelemetryContext) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.buildStamp = _data["buildStamp"] ? BuildStamp.fromJS(_data["buildStamp"]) : <any>undefined;
            this.environment = _data["environment"];
            this.userAgent = _data["userAgent"];
            if (_data["extras"]) {
                this.extras = {} as any;
                for (let key in _data["extras"]) {
                    if (_data["extras"].hasOwnProperty(key))
                        (<any>this.extras)![key] = _data["extras"][key];
                }
            }
        }
    }

    static fromJS(data: any): TelemetryContext {
        data = typeof data === 'object' ? data : {};
        let result = new TelemetryContext();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["buildStamp"] = this.buildStamp ? this.buildStamp.toJSON() : <any>undefined;
        data["environment"] = this.environment;
        data["userAgent"] = this.userAgent;
        if (this.extras) {
            data["extras"] = {};
            for (let key in this.extras) {
                if (this.extras.hasOwnProperty(key))
                    (<any>data["extras"])[key] = (<any>this.extras)[key];
            }
        }
        return data;
    }
}

export interface ITelemetryContext {
    buildStamp?: BuildStamp;
    environment?: string | undefined;
    userAgent?: string | undefined;
    extras?: { [key: string]: string; } | undefined;
}

export enum UnitKind {
    Weight = "Weight",
    Volume = "Volume",
    Count = "Count",
    Unknown = "Unknown",
}

export class UpdateMealSelectionRequest implements IUpdateMealSelectionRequest {
    messageId?: string | undefined;
    localDateKey?: string | undefined;
    foods?: Food[] | undefined;
    mealName?: string | undefined;

    constructor(data?: IUpdateMealSelectionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.messageId = _data["messageId"];
            this.localDateKey = _data["localDateKey"];
            if (Array.isArray(_data["foods"])) {
                this.foods = [] as any;
                for (let item of _data["foods"])
                    this.foods!.push(Food.fromJS(item));
            }
            this.mealName = _data["mealName"];
        }
    }

    static fromJS(data: any): UpdateMealSelectionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMealSelectionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["messageId"] = this.messageId;
        data["localDateKey"] = this.localDateKey;
        if (Array.isArray(this.foods)) {
            data["foods"] = [];
            for (let item of this.foods)
                data["foods"].push(item.toJSON());
        }
        data["mealName"] = this.mealName;
        return data;
    }
}

export interface IUpdateMealSelectionRequest {
    messageId?: string | undefined;
    localDateKey?: string | undefined;
    foods?: Food[] | undefined;
    mealName?: string | undefined;
}

export class UploadGuidelineFileRequest implements IUploadGuidelineFileRequest {
    fileName?: string | undefined;
    contentType?: string | undefined;
    base64Data?: string | undefined;

    constructor(data?: IUploadGuidelineFileRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileName = _data["fileName"];
            this.contentType = _data["contentType"];
            this.base64Data = _data["base64Data"];
        }
    }

    static fromJS(data: any): UploadGuidelineFileRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UploadGuidelineFileRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["contentType"] = this.contentType;
        data["base64Data"] = this.base64Data;
        return data;
    }
}

export interface IUploadGuidelineFileRequest {
    fileName?: string | undefined;
    contentType?: string | undefined;
    base64Data?: string | undefined;
}

export class UploadGuidelineFileResponse implements IUploadGuidelineFileResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;
    openAiFileId?: string | undefined;
    openAiFileApiId?: string | undefined;
    vectorStoreId?: string | undefined;
    status?: string | undefined;

    constructor(data?: IUploadGuidelineFileResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.correlationId = _data["correlationId"];
            this.stackTrace = _data["stackTrace"];
            this.accountId = _data["accountId"];
            this.isPartial = _data["isPartial"];
            this.processingStage = _data["processingStage"];
            this.messageId = _data["messageId"];
            this.openAiFileId = _data["openAiFileId"];
            this.openAiFileApiId = _data["openAiFileApiId"];
            this.vectorStoreId = _data["vectorStoreId"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): UploadGuidelineFileResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UploadGuidelineFileResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["correlationId"] = this.correlationId;
        data["stackTrace"] = this.stackTrace;
        data["accountId"] = this.accountId;
        data["isPartial"] = this.isPartial;
        data["processingStage"] = this.processingStage;
        data["messageId"] = this.messageId;
        data["openAiFileId"] = this.openAiFileId;
        data["openAiFileApiId"] = this.openAiFileApiId;
        data["vectorStoreId"] = this.vectorStoreId;
        data["status"] = this.status;
        return data;
    }
}

export interface IUploadGuidelineFileResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    isPartial?: boolean;
    processingStage?: string | undefined;
    messageId?: string | undefined;
    openAiFileId?: string | undefined;
    openAiFileApiId?: string | undefined;
    vectorStoreId?: string | undefined;
    status?: string | undefined;
}

export class UserSelectedFoodQuantity implements IUserSelectedFoodQuantity {
    foodId?: string | undefined;
    quantity?: number;

    constructor(data?: IUserSelectedFoodQuantity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.foodId = _data["foodId"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): UserSelectedFoodQuantity {
        data = typeof data === 'object' ? data : {};
        let result = new UserSelectedFoodQuantity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["foodId"] = this.foodId;
        data["quantity"] = this.quantity;
        return data;
    }
}

export interface IUserSelectedFoodQuantity {
    foodId?: string | undefined;
    quantity?: number;
}

export class UserSelectedServing implements IUserSelectedServing {
    originalText?: string | undefined;
    provider?: string | undefined;
    providerFoodId?: string | undefined;
    servingId?: ServingIdentifier;
    editedQuantity?: number | undefined;
    componentId?: string | undefined;
    scaledQuantity?: number | undefined;

    constructor(data?: IUserSelectedServing) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.originalText = _data["originalText"];
            this.provider = _data["provider"];
            this.providerFoodId = _data["providerFoodId"];
            this.servingId = _data["servingId"] ? ServingIdentifier.fromJS(_data["servingId"]) : <any>undefined;
            this.editedQuantity = _data["editedQuantity"];
            this.componentId = _data["componentId"];
            this.scaledQuantity = _data["scaledQuantity"];
        }
    }

    static fromJS(data: any): UserSelectedServing {
        data = typeof data === 'object' ? data : {};
        let result = new UserSelectedServing();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["originalText"] = this.originalText;
        data["provider"] = this.provider;
        data["providerFoodId"] = this.providerFoodId;
        data["servingId"] = this.servingId ? this.servingId.toJSON() : <any>undefined;
        data["editedQuantity"] = this.editedQuantity;
        data["componentId"] = this.componentId;
        data["scaledQuantity"] = this.scaledQuantity;
        return data;
    }
}

export interface IUserSelectedServing {
    originalText?: string | undefined;
    provider?: string | undefined;
    providerFoodId?: string | undefined;
    servingId?: ServingIdentifier;
    editedQuantity?: number | undefined;
    componentId?: string | undefined;
    scaledQuantity?: number | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}