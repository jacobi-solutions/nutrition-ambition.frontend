//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface INutritionAmbitionApiService {
    /**
     * @param body (optional) 
     * @return Success
     */
    getAccount(body: Request | undefined): Observable<AccountResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getChatMessages(body: GetChatMessagesRequest | undefined): Observable<GetChatMessagesResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    clearChatMessages(body: ClearChatMessagesRequest | undefined): Observable<ClearChatMessagesResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    runResponsesConversation(body: RunChatRequest | undefined): Observable<BotMessageResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    learnMoreAbout(body: LearnMoreAboutRequest | undefined): Observable<BotMessageResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    submitServingSelection(body: SubmitServingSelectionRequest | undefined): Observable<SubmitServingSelectionResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getDetailedSummary(body: GetDetailedSummaryRequest | undefined): Observable<GetDetailedSummaryResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    submitFeedback(body: SubmitUserFeedbackRequest | undefined): Observable<SubmitUserFeedbackResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getFeedback(body: GetFeedbackRequest | undefined): Observable<GetFeedbackResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateFeedback(body: UpdateFeedbackRequest | undefined): Observable<UpdateFeedbackResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    deleteFeedback(body: DeleteFeedbackRequest | undefined): Observable<DeleteFeedbackResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getAllFeedback(body: GetFeedbackRequest | undefined): Observable<GetFeedbackResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    completeFeedback(body: CompleteFeedbackRequest | undefined): Observable<CompleteFeedbackResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getFoodEntries(body: GetFoodEntriesRequest | undefined): Observable<GetFoodEntriesResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateFoodEntry(body: UpdateFoodEntryRequest | undefined): Observable<UpdateFoodEntryResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    deleteFoodEntry(body: DeleteFoodEntryRequest | undefined): Observable<DeleteFoodEntryResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    submitServingSelection2(body: SubmitServingSelectionRequest | undefined): Observable<SubmitServingSelectionResponse>;
    /**
     * @return Success
     */
    ip(): Observable<void>;
}

@Injectable()
export class NutritionAmbitionApiService implements INutritionAmbitionApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAccount(body: Request | undefined): Observable<AccountResponse> {
        let url_ = this.baseUrl + "/api/Accounts/GetAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountResponse>;
        }));
    }

    protected processGetAccount(response: HttpResponseBase): Observable<AccountResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccountResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getChatMessages(body: GetChatMessagesRequest | undefined): Observable<GetChatMessagesResponse> {
        let url_ = this.baseUrl + "/api/Conversation/GetChatMessages";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetChatMessages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChatMessages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetChatMessagesResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetChatMessagesResponse>;
        }));
    }

    protected processGetChatMessages(response: HttpResponseBase): Observable<GetChatMessagesResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetChatMessagesResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetChatMessagesResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    clearChatMessages(body: ClearChatMessagesRequest | undefined): Observable<ClearChatMessagesResponse> {
        let url_ = this.baseUrl + "/api/Conversation/ClearChatMessages";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearChatMessages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearChatMessages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClearChatMessagesResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClearChatMessagesResponse>;
        }));
    }

    protected processClearChatMessages(response: HttpResponseBase): Observable<ClearChatMessagesResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClearChatMessagesResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClearChatMessagesResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    runResponsesConversation(body: RunChatRequest | undefined): Observable<BotMessageResponse> {
        let url_ = this.baseUrl + "/api/Conversation/RunResponsesConversation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRunResponsesConversation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRunResponsesConversation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BotMessageResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BotMessageResponse>;
        }));
    }

    protected processRunResponsesConversation(response: HttpResponseBase): Observable<BotMessageResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BotMessageResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BotMessageResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    learnMoreAbout(body: LearnMoreAboutRequest | undefined): Observable<BotMessageResponse> {
        let url_ = this.baseUrl + "/api/Conversation/LearnMoreAbout";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLearnMoreAbout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLearnMoreAbout(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BotMessageResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BotMessageResponse>;
        }));
    }

    protected processLearnMoreAbout(response: HttpResponseBase): Observable<BotMessageResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BotMessageResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BotMessageResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    submitServingSelection(body: SubmitServingSelectionRequest | undefined): Observable<SubmitServingSelectionResponse> {
        let url_ = this.baseUrl + "/api/Conversation/SubmitServingSelection";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmitServingSelection(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitServingSelection(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubmitServingSelectionResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubmitServingSelectionResponse>;
        }));
    }

    protected processSubmitServingSelection(response: HttpResponseBase): Observable<SubmitServingSelectionResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubmitServingSelectionResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubmitServingSelectionResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getDetailedSummary(body: GetDetailedSummaryRequest | undefined): Observable<GetDetailedSummaryResponse> {
        let url_ = this.baseUrl + "/api/DetailedSummary/GetDetailedSummary";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetailedSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetailedSummary(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetDetailedSummaryResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetDetailedSummaryResponse>;
        }));
    }

    protected processGetDetailedSummary(response: HttpResponseBase): Observable<GetDetailedSummaryResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetDetailedSummaryResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDetailedSummaryResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    submitFeedback(body: SubmitUserFeedbackRequest | undefined): Observable<SubmitUserFeedbackResponse> {
        let url_ = this.baseUrl + "/api/Feedback/SubmitFeedback";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmitFeedback(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitFeedback(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubmitUserFeedbackResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubmitUserFeedbackResponse>;
        }));
    }

    protected processSubmitFeedback(response: HttpResponseBase): Observable<SubmitUserFeedbackResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubmitUserFeedbackResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubmitUserFeedbackResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getFeedback(body: GetFeedbackRequest | undefined): Observable<GetFeedbackResponse> {
        let url_ = this.baseUrl + "/api/Feedback/GetFeedback";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFeedback(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFeedback(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetFeedbackResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetFeedbackResponse>;
        }));
    }

    protected processGetFeedback(response: HttpResponseBase): Observable<GetFeedbackResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetFeedbackResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetFeedbackResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateFeedback(body: UpdateFeedbackRequest | undefined): Observable<UpdateFeedbackResponse> {
        let url_ = this.baseUrl + "/api/Feedback/UpdateFeedback";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateFeedback(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateFeedback(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateFeedbackResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateFeedbackResponse>;
        }));
    }

    protected processUpdateFeedback(response: HttpResponseBase): Observable<UpdateFeedbackResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateFeedbackResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateFeedbackResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteFeedback(body: DeleteFeedbackRequest | undefined): Observable<DeleteFeedbackResponse> {
        let url_ = this.baseUrl + "/api/Feedback/DeleteFeedback";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteFeedback(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteFeedback(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DeleteFeedbackResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DeleteFeedbackResponse>;
        }));
    }

    protected processDeleteFeedback(response: HttpResponseBase): Observable<DeleteFeedbackResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeleteFeedbackResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeleteFeedbackResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAllFeedback(body: GetFeedbackRequest | undefined): Observable<GetFeedbackResponse> {
        let url_ = this.baseUrl + "/api/Feedback/GetAllFeedback";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllFeedback(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllFeedback(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetFeedbackResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetFeedbackResponse>;
        }));
    }

    protected processGetAllFeedback(response: HttpResponseBase): Observable<GetFeedbackResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetFeedbackResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetFeedbackResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    completeFeedback(body: CompleteFeedbackRequest | undefined): Observable<CompleteFeedbackResponse> {
        let url_ = this.baseUrl + "/api/Feedback/CompleteFeedback";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompleteFeedback(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompleteFeedback(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompleteFeedbackResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompleteFeedbackResponse>;
        }));
    }

    protected processCompleteFeedback(response: HttpResponseBase): Observable<CompleteFeedbackResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompleteFeedbackResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompleteFeedbackResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getFoodEntries(body: GetFoodEntriesRequest | undefined): Observable<GetFoodEntriesResponse> {
        let url_ = this.baseUrl + "/api/FoodEntry/GetFoodEntries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFoodEntries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFoodEntries(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetFoodEntriesResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetFoodEntriesResponse>;
        }));
    }

    protected processGetFoodEntries(response: HttpResponseBase): Observable<GetFoodEntriesResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetFoodEntriesResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetFoodEntriesResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateFoodEntry(body: UpdateFoodEntryRequest | undefined): Observable<UpdateFoodEntryResponse> {
        let url_ = this.baseUrl + "/api/FoodEntry/UpdateFoodEntry";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateFoodEntry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateFoodEntry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateFoodEntryResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateFoodEntryResponse>;
        }));
    }

    protected processUpdateFoodEntry(response: HttpResponseBase): Observable<UpdateFoodEntryResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateFoodEntryResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateFoodEntryResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteFoodEntry(body: DeleteFoodEntryRequest | undefined): Observable<DeleteFoodEntryResponse> {
        let url_ = this.baseUrl + "/api/FoodEntry/DeleteFoodEntry";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteFoodEntry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteFoodEntry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DeleteFoodEntryResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DeleteFoodEntryResponse>;
        }));
    }

    protected processDeleteFoodEntry(response: HttpResponseBase): Observable<DeleteFoodEntryResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeleteFoodEntryResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeleteFoodEntryResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    submitServingSelection2(body: SubmitServingSelectionRequest | undefined): Observable<SubmitServingSelectionResponse> {
        let url_ = this.baseUrl + "/api/FoodSelection/SubmitServingSelection";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmitServingSelection2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitServingSelection2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubmitServingSelectionResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubmitServingSelectionResponse>;
        }));
    }

    protected processSubmitServingSelection2(response: HttpResponseBase): Observable<SubmitServingSelectionResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubmitServingSelectionResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubmitServingSelectionResponse>(null as any);
    }

    /**
     * @return Success
     */
    ip(): Observable<void> {
        let url_ = this.baseUrl + "/api/Test/ip";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processIp(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

export class Account implements IAccount {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    name?: string | undefined;
    email?: string | undefined;
    timeZoneId?: string | undefined;
    isOwner?: boolean;
    hasUnacknowledgedFeedbackResponses?: boolean;

    constructor(data?: IAccount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdDateUtc = _data["createdDateUtc"] ? new Date(_data["createdDateUtc"].toString()) : <any>undefined;
            this.lastUpdatedDateUtc = _data["lastUpdatedDateUtc"] ? new Date(_data["lastUpdatedDateUtc"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.email = _data["email"];
            this.timeZoneId = _data["timeZoneId"];
            this.isOwner = _data["isOwner"];
            this.hasUnacknowledgedFeedbackResponses = _data["hasUnacknowledgedFeedbackResponses"];
        }
    }

    static fromJS(data: any): Account {
        data = typeof data === 'object' ? data : {};
        let result = new Account();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdDateUtc"] = this.createdDateUtc ? this.createdDateUtc.toISOString() : <any>undefined;
        data["lastUpdatedDateUtc"] = this.lastUpdatedDateUtc ? this.lastUpdatedDateUtc.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["email"] = this.email;
        data["timeZoneId"] = this.timeZoneId;
        data["isOwner"] = this.isOwner;
        data["hasUnacknowledgedFeedbackResponses"] = this.hasUnacknowledgedFeedbackResponses;
        return data;
    }
}

export interface IAccount {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    name?: string | undefined;
    email?: string | undefined;
    timeZoneId?: string | undefined;
    isOwner?: boolean;
    hasUnacknowledgedFeedbackResponses?: boolean;
}

export class AccountResponse implements IAccountResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    account?: Account;

    constructor(data?: IAccountResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.correlationId = _data["correlationId"];
            this.stackTrace = _data["stackTrace"];
            this.accountId = _data["accountId"];
            this.account = _data["account"] ? Account.fromJS(_data["account"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AccountResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AccountResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["correlationId"] = this.correlationId;
        data["stackTrace"] = this.stackTrace;
        data["accountId"] = this.accountId;
        data["account"] = this.account ? this.account.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAccountResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    account?: Account;
}

export enum AssistantModeTypes {
    Default = "Default",
    GoalSetting = "GoalSetting",
    UserFeedback = "UserFeedback",
}

export class BotMessageResponse implements IBotMessageResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    message?: string | undefined;
    accountId?: string | undefined;
    logMealToolResponse?: LogMealToolResponse;
    terminateEarlyForUserInput?: boolean;
    responseId?: string | undefined;
    loggedMeal?: boolean;
    assistantMode?: AssistantModeTypes;
    assistantPhase?: string | undefined;
    model?: string | undefined;
    usage?: TokenUsage;

    constructor(data?: IBotMessageResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.correlationId = _data["correlationId"];
            this.stackTrace = _data["stackTrace"];
            this.message = _data["message"];
            this.accountId = _data["accountId"];
            this.logMealToolResponse = _data["logMealToolResponse"] ? LogMealToolResponse.fromJS(_data["logMealToolResponse"]) : <any>undefined;
            this.terminateEarlyForUserInput = _data["terminateEarlyForUserInput"];
            this.responseId = _data["responseId"];
            this.loggedMeal = _data["loggedMeal"];
            this.assistantMode = _data["assistantMode"];
            this.assistantPhase = _data["assistantPhase"];
            this.model = _data["model"];
            this.usage = _data["usage"] ? TokenUsage.fromJS(_data["usage"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BotMessageResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BotMessageResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["correlationId"] = this.correlationId;
        data["stackTrace"] = this.stackTrace;
        data["message"] = this.message;
        data["accountId"] = this.accountId;
        data["logMealToolResponse"] = this.logMealToolResponse ? this.logMealToolResponse.toJSON() : <any>undefined;
        data["terminateEarlyForUserInput"] = this.terminateEarlyForUserInput;
        data["responseId"] = this.responseId;
        data["loggedMeal"] = this.loggedMeal;
        data["assistantMode"] = this.assistantMode;
        data["assistantPhase"] = this.assistantPhase;
        data["model"] = this.model;
        data["usage"] = this.usage ? this.usage.toJSON() : <any>undefined;
        return data;
    }
}

export interface IBotMessageResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    message?: string | undefined;
    accountId?: string | undefined;
    logMealToolResponse?: LogMealToolResponse;
    terminateEarlyForUserInput?: boolean;
    responseId?: string | undefined;
    loggedMeal?: boolean;
    assistantMode?: AssistantModeTypes;
    assistantPhase?: string | undefined;
    model?: string | undefined;
    usage?: TokenUsage;
}

export class ChatMessage implements IChatMessage {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    accountId?: string | undefined;
    role?: MessageRoleTypes;
    content?: string | undefined;
    loggedDateUtc?: Date;
    foodEntryId?: string | undefined;
    isRead?: boolean;
    toolCallId?: string | undefined;
    toolFunctionName?: string | undefined;
    toolCallArgumentsJson?: string | undefined;
    responseId?: string | undefined;
    assistantMode?: AssistantModeTypes;
    assistantPhase?: string | undefined;
    logMealToolResponse?: LogMealToolResponse;
    modelUsed?: string | undefined;
    promptTokens?: number | undefined;
    completionTokens?: number | undefined;
    totalTokens?: number | undefined;

    constructor(data?: IChatMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdDateUtc = _data["createdDateUtc"] ? new Date(_data["createdDateUtc"].toString()) : <any>undefined;
            this.lastUpdatedDateUtc = _data["lastUpdatedDateUtc"] ? new Date(_data["lastUpdatedDateUtc"].toString()) : <any>undefined;
            this.accountId = _data["accountId"];
            this.role = _data["role"];
            this.content = _data["content"];
            this.loggedDateUtc = _data["loggedDateUtc"] ? new Date(_data["loggedDateUtc"].toString()) : <any>undefined;
            this.foodEntryId = _data["foodEntryId"];
            this.isRead = _data["isRead"];
            this.toolCallId = _data["toolCallId"];
            this.toolFunctionName = _data["toolFunctionName"];
            this.toolCallArgumentsJson = _data["toolCallArgumentsJson"];
            this.responseId = _data["responseId"];
            this.assistantMode = _data["assistantMode"];
            this.assistantPhase = _data["assistantPhase"];
            this.logMealToolResponse = _data["logMealToolResponse"] ? LogMealToolResponse.fromJS(_data["logMealToolResponse"]) : <any>undefined;
            this.modelUsed = _data["modelUsed"];
            this.promptTokens = _data["promptTokens"];
            this.completionTokens = _data["completionTokens"];
            this.totalTokens = _data["totalTokens"];
        }
    }

    static fromJS(data: any): ChatMessage {
        data = typeof data === 'object' ? data : {};
        let result = new ChatMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdDateUtc"] = this.createdDateUtc ? this.createdDateUtc.toISOString() : <any>undefined;
        data["lastUpdatedDateUtc"] = this.lastUpdatedDateUtc ? this.lastUpdatedDateUtc.toISOString() : <any>undefined;
        data["accountId"] = this.accountId;
        data["role"] = this.role;
        data["content"] = this.content;
        data["loggedDateUtc"] = this.loggedDateUtc ? this.loggedDateUtc.toISOString() : <any>undefined;
        data["foodEntryId"] = this.foodEntryId;
        data["isRead"] = this.isRead;
        data["toolCallId"] = this.toolCallId;
        data["toolFunctionName"] = this.toolFunctionName;
        data["toolCallArgumentsJson"] = this.toolCallArgumentsJson;
        data["responseId"] = this.responseId;
        data["assistantMode"] = this.assistantMode;
        data["assistantPhase"] = this.assistantPhase;
        data["logMealToolResponse"] = this.logMealToolResponse ? this.logMealToolResponse.toJSON() : <any>undefined;
        data["modelUsed"] = this.modelUsed;
        data["promptTokens"] = this.promptTokens;
        data["completionTokens"] = this.completionTokens;
        data["totalTokens"] = this.totalTokens;
        return data;
    }
}

export interface IChatMessage {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    accountId?: string | undefined;
    role?: MessageRoleTypes;
    content?: string | undefined;
    loggedDateUtc?: Date;
    foodEntryId?: string | undefined;
    isRead?: boolean;
    toolCallId?: string | undefined;
    toolFunctionName?: string | undefined;
    toolCallArgumentsJson?: string | undefined;
    responseId?: string | undefined;
    assistantMode?: AssistantModeTypes;
    assistantPhase?: string | undefined;
    logMealToolResponse?: LogMealToolResponse;
    modelUsed?: string | undefined;
    promptTokens?: number | undefined;
    completionTokens?: number | undefined;
    totalTokens?: number | undefined;
}

export class ClearChatMessagesRequest implements IClearChatMessagesRequest {
    loggedDateUtc?: Date | undefined;

    constructor(data?: IClearChatMessagesRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.loggedDateUtc = _data["loggedDateUtc"] ? new Date(_data["loggedDateUtc"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ClearChatMessagesRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ClearChatMessagesRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loggedDateUtc"] = this.loggedDateUtc ? this.loggedDateUtc.toISOString() : <any>undefined;
        return data;
    }
}

export interface IClearChatMessagesRequest {
    loggedDateUtc?: Date | undefined;
}

export class ClearChatMessagesResponse implements IClearChatMessagesResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    success?: boolean;
    messagesDeleted?: number;

    constructor(data?: IClearChatMessagesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.correlationId = _data["correlationId"];
            this.stackTrace = _data["stackTrace"];
            this.accountId = _data["accountId"];
            this.success = _data["success"];
            this.messagesDeleted = _data["messagesDeleted"];
        }
    }

    static fromJS(data: any): ClearChatMessagesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ClearChatMessagesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["correlationId"] = this.correlationId;
        data["stackTrace"] = this.stackTrace;
        data["accountId"] = this.accountId;
        data["success"] = this.success;
        data["messagesDeleted"] = this.messagesDeleted;
        return data;
    }
}

export interface IClearChatMessagesResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    success?: boolean;
    messagesDeleted?: number;
}

export class CompleteFeedbackRequest implements ICompleteFeedbackRequest {
    feedbackId?: string | undefined;
    completionNote!: string;
    isCompleted?: boolean;

    constructor(data?: ICompleteFeedbackRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.feedbackId = _data["feedbackId"];
            this.completionNote = _data["completionNote"];
            this.isCompleted = _data["isCompleted"];
        }
    }

    static fromJS(data: any): CompleteFeedbackRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CompleteFeedbackRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["feedbackId"] = this.feedbackId;
        data["completionNote"] = this.completionNote;
        data["isCompleted"] = this.isCompleted;
        return data;
    }
}

export interface ICompleteFeedbackRequest {
    feedbackId?: string | undefined;
    completionNote: string;
    isCompleted?: boolean;
}

export class CompleteFeedbackResponse implements ICompleteFeedbackResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    feedbackEntry?: FeedbackEntry;

    constructor(data?: ICompleteFeedbackResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.correlationId = _data["correlationId"];
            this.stackTrace = _data["stackTrace"];
            this.accountId = _data["accountId"];
            this.feedbackEntry = _data["feedbackEntry"] ? FeedbackEntry.fromJS(_data["feedbackEntry"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CompleteFeedbackResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CompleteFeedbackResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["correlationId"] = this.correlationId;
        data["stackTrace"] = this.stackTrace;
        data["accountId"] = this.accountId;
        data["feedbackEntry"] = this.feedbackEntry ? this.feedbackEntry.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICompleteFeedbackResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    feedbackEntry?: FeedbackEntry;
}

export class DeleteFeedbackRequest implements IDeleteFeedbackRequest {
    feedbackId?: string | undefined;

    constructor(data?: IDeleteFeedbackRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.feedbackId = _data["feedbackId"];
        }
    }

    static fromJS(data: any): DeleteFeedbackRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteFeedbackRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["feedbackId"] = this.feedbackId;
        return data;
    }
}

export interface IDeleteFeedbackRequest {
    feedbackId?: string | undefined;
}

export class DeleteFeedbackResponse implements IDeleteFeedbackResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    deleted?: boolean;

    constructor(data?: IDeleteFeedbackResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.correlationId = _data["correlationId"];
            this.stackTrace = _data["stackTrace"];
            this.accountId = _data["accountId"];
            this.deleted = _data["deleted"];
        }
    }

    static fromJS(data: any): DeleteFeedbackResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteFeedbackResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["correlationId"] = this.correlationId;
        data["stackTrace"] = this.stackTrace;
        data["accountId"] = this.accountId;
        data["deleted"] = this.deleted;
        return data;
    }
}

export interface IDeleteFeedbackResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    deleted?: boolean;
}

export class DeleteFoodEntryRequest implements IDeleteFoodEntryRequest {
    foodItemIds?: string[] | undefined;

    constructor(data?: IDeleteFoodEntryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["foodItemIds"])) {
                this.foodItemIds = [] as any;
                for (let item of _data["foodItemIds"])
                    this.foodItemIds!.push(item);
            }
        }
    }

    static fromJS(data: any): DeleteFoodEntryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteFoodEntryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.foodItemIds)) {
            data["foodItemIds"] = [];
            for (let item of this.foodItemIds)
                data["foodItemIds"].push(item);
        }
        return data;
    }
}

export interface IDeleteFoodEntryRequest {
    foodItemIds?: string[] | undefined;
}

export class DeleteFoodEntryResponse implements IDeleteFoodEntryResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;

    constructor(data?: IDeleteFoodEntryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.correlationId = _data["correlationId"];
            this.stackTrace = _data["stackTrace"];
            this.accountId = _data["accountId"];
        }
    }

    static fromJS(data: any): DeleteFoodEntryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteFoodEntryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["correlationId"] = this.correlationId;
        data["stackTrace"] = this.stackTrace;
        data["accountId"] = this.accountId;
        return data;
    }
}

export interface IDeleteFoodEntryResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
}

export class ErrorDto implements IErrorDto {
    errorMessage?: string | undefined;
    errorCode?: string | undefined;

    constructor(data?: IErrorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
        }
    }

    static fromJS(data: any): ErrorDto {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        return data;
    }
}

export interface IErrorDto {
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
}

export class FeedbackEntry implements IFeedbackEntry {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    accountId?: string | undefined;
    feedbackType?: string | undefined;
    message?: string | undefined;
    context?: string | undefined;
    isCompleted?: boolean;
    completedDateUtc?: Date | undefined;
    completionNote?: string | undefined;
    completedByAccountId?: string | undefined;
    isAssistantResponseShown?: boolean;
    assistantResponseShownDateUtc?: Date | undefined;

    constructor(data?: IFeedbackEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdDateUtc = _data["createdDateUtc"] ? new Date(_data["createdDateUtc"].toString()) : <any>undefined;
            this.lastUpdatedDateUtc = _data["lastUpdatedDateUtc"] ? new Date(_data["lastUpdatedDateUtc"].toString()) : <any>undefined;
            this.accountId = _data["accountId"];
            this.feedbackType = _data["feedbackType"];
            this.message = _data["message"];
            this.context = _data["context"];
            this.isCompleted = _data["isCompleted"];
            this.completedDateUtc = _data["completedDateUtc"] ? new Date(_data["completedDateUtc"].toString()) : <any>undefined;
            this.completionNote = _data["completionNote"];
            this.completedByAccountId = _data["completedByAccountId"];
            this.isAssistantResponseShown = _data["isAssistantResponseShown"];
            this.assistantResponseShownDateUtc = _data["assistantResponseShownDateUtc"] ? new Date(_data["assistantResponseShownDateUtc"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): FeedbackEntry {
        data = typeof data === 'object' ? data : {};
        let result = new FeedbackEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdDateUtc"] = this.createdDateUtc ? this.createdDateUtc.toISOString() : <any>undefined;
        data["lastUpdatedDateUtc"] = this.lastUpdatedDateUtc ? this.lastUpdatedDateUtc.toISOString() : <any>undefined;
        data["accountId"] = this.accountId;
        data["feedbackType"] = this.feedbackType;
        data["message"] = this.message;
        data["context"] = this.context;
        data["isCompleted"] = this.isCompleted;
        data["completedDateUtc"] = this.completedDateUtc ? this.completedDateUtc.toISOString() : <any>undefined;
        data["completionNote"] = this.completionNote;
        data["completedByAccountId"] = this.completedByAccountId;
        data["isAssistantResponseShown"] = this.isAssistantResponseShown;
        data["assistantResponseShownDateUtc"] = this.assistantResponseShownDateUtc ? this.assistantResponseShownDateUtc.toISOString() : <any>undefined;
        return data;
    }
}

export interface IFeedbackEntry {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    accountId?: string | undefined;
    feedbackType?: string | undefined;
    message?: string | undefined;
    context?: string | undefined;
    isCompleted?: boolean;
    completedDateUtc?: Date | undefined;
    completionNote?: string | undefined;
    completedByAccountId?: string | undefined;
    isAssistantResponseShown?: boolean;
    assistantResponseShownDateUtc?: Date | undefined;
}

export class FoodBreakdown implements IFoodBreakdown {
    foodItemIds?: string[] | undefined;
    name?: string | undefined;
    brandName?: string | undefined;
    totalAmount?: number;
    unit?: string | undefined;
    nutrients?: NutrientContribution[] | undefined;

    constructor(data?: IFoodBreakdown) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["foodItemIds"])) {
                this.foodItemIds = [] as any;
                for (let item of _data["foodItemIds"])
                    this.foodItemIds!.push(item);
            }
            this.name = _data["name"];
            this.brandName = _data["brandName"];
            this.totalAmount = _data["totalAmount"];
            this.unit = _data["unit"];
            if (Array.isArray(_data["nutrients"])) {
                this.nutrients = [] as any;
                for (let item of _data["nutrients"])
                    this.nutrients!.push(NutrientContribution.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FoodBreakdown {
        data = typeof data === 'object' ? data : {};
        let result = new FoodBreakdown();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.foodItemIds)) {
            data["foodItemIds"] = [];
            for (let item of this.foodItemIds)
                data["foodItemIds"].push(item);
        }
        data["name"] = this.name;
        data["brandName"] = this.brandName;
        data["totalAmount"] = this.totalAmount;
        data["unit"] = this.unit;
        if (Array.isArray(this.nutrients)) {
            data["nutrients"] = [];
            for (let item of this.nutrients)
                data["nutrients"].push(item.toJSON());
        }
        return data;
    }
}

export interface IFoodBreakdown {
    foodItemIds?: string[] | undefined;
    name?: string | undefined;
    brandName?: string | undefined;
    totalAmount?: number;
    unit?: string | undefined;
    nutrients?: NutrientContribution[] | undefined;
}

export class FoodContribution implements IFoodContribution {
    name?: string | undefined;
    brandName?: string | undefined;
    amount?: number;
    unit?: string | undefined;
    foodUnit?: string | undefined;
    displayQuantity?: number;

    constructor(data?: IFoodContribution) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.brandName = _data["brandName"];
            this.amount = _data["amount"];
            this.unit = _data["unit"];
            this.foodUnit = _data["foodUnit"];
            this.displayQuantity = _data["displayQuantity"];
        }
    }

    static fromJS(data: any): FoodContribution {
        data = typeof data === 'object' ? data : {};
        let result = new FoodContribution();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["brandName"] = this.brandName;
        data["amount"] = this.amount;
        data["unit"] = this.unit;
        data["foodUnit"] = this.foodUnit;
        data["displayQuantity"] = this.displayQuantity;
        return data;
    }
}

export interface IFoodContribution {
    name?: string | undefined;
    brandName?: string | undefined;
    amount?: number;
    unit?: string | undefined;
    foodUnit?: string | undefined;
    displayQuantity?: number;
}

export class FoodEntry implements IFoodEntry {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    accountId?: string | undefined;
    description?: string | undefined;
    loggedDateUtc?: Date;
    meal?: MealType;
    groupedItems?: FoodGroup[] | undefined;

    constructor(data?: IFoodEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdDateUtc = _data["createdDateUtc"] ? new Date(_data["createdDateUtc"].toString()) : <any>undefined;
            this.lastUpdatedDateUtc = _data["lastUpdatedDateUtc"] ? new Date(_data["lastUpdatedDateUtc"].toString()) : <any>undefined;
            this.accountId = _data["accountId"];
            this.description = _data["description"];
            this.loggedDateUtc = _data["loggedDateUtc"] ? new Date(_data["loggedDateUtc"].toString()) : <any>undefined;
            this.meal = _data["meal"];
            if (Array.isArray(_data["groupedItems"])) {
                this.groupedItems = [] as any;
                for (let item of _data["groupedItems"])
                    this.groupedItems!.push(FoodGroup.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FoodEntry {
        data = typeof data === 'object' ? data : {};
        let result = new FoodEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdDateUtc"] = this.createdDateUtc ? this.createdDateUtc.toISOString() : <any>undefined;
        data["lastUpdatedDateUtc"] = this.lastUpdatedDateUtc ? this.lastUpdatedDateUtc.toISOString() : <any>undefined;
        data["accountId"] = this.accountId;
        data["description"] = this.description;
        data["loggedDateUtc"] = this.loggedDateUtc ? this.loggedDateUtc.toISOString() : <any>undefined;
        data["meal"] = this.meal;
        if (Array.isArray(this.groupedItems)) {
            data["groupedItems"] = [];
            for (let item of this.groupedItems)
                data["groupedItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface IFoodEntry {
    id?: string | undefined;
    createdDateUtc?: Date;
    lastUpdatedDateUtc?: Date;
    accountId?: string | undefined;
    description?: string | undefined;
    loggedDateUtc?: Date;
    meal?: MealType;
    groupedItems?: FoodGroup[] | undefined;
}

export class FoodGroup implements IFoodGroup {
    groupName?: string | undefined;
    items?: FoodItem[] | undefined;

    constructor(data?: IFoodGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.groupName = _data["groupName"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(FoodItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FoodGroup {
        data = typeof data === 'object' ? data : {};
        let result = new FoodGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupName"] = this.groupName;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IFoodGroup {
    groupName?: string | undefined;
    items?: FoodItem[] | undefined;
}

export class FoodItem implements IFoodItem {
    id?: string | undefined;
    name?: string | undefined;
    brandName?: string | undefined;
    fatSecretFoodId?: string | undefined;
    fatSecretServingId?: string | undefined;
    scaleFactor?: number;
    quantity?: number;
    unit?: string | undefined;
    weightGramsPerUnit?: number | undefined;
    nutrients?: { [key: string]: number; } | undefined;
    apiServingKind?: UnitKind;

    constructor(data?: IFoodItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.brandName = _data["brandName"];
            this.fatSecretFoodId = _data["fatSecretFoodId"];
            this.fatSecretServingId = _data["fatSecretServingId"];
            this.scaleFactor = _data["scaleFactor"];
            this.quantity = _data["quantity"];
            this.unit = _data["unit"];
            this.weightGramsPerUnit = _data["weightGramsPerUnit"];
            if (_data["nutrients"]) {
                this.nutrients = {} as any;
                for (let key in _data["nutrients"]) {
                    if (_data["nutrients"].hasOwnProperty(key))
                        (<any>this.nutrients)![key] = _data["nutrients"][key];
                }
            }
            this.apiServingKind = _data["apiServingKind"];
        }
    }

    static fromJS(data: any): FoodItem {
        data = typeof data === 'object' ? data : {};
        let result = new FoodItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["brandName"] = this.brandName;
        data["fatSecretFoodId"] = this.fatSecretFoodId;
        data["fatSecretServingId"] = this.fatSecretServingId;
        data["scaleFactor"] = this.scaleFactor;
        data["quantity"] = this.quantity;
        data["unit"] = this.unit;
        data["weightGramsPerUnit"] = this.weightGramsPerUnit;
        if (this.nutrients) {
            data["nutrients"] = {};
            for (let key in this.nutrients) {
                if (this.nutrients.hasOwnProperty(key))
                    (<any>data["nutrients"])[key] = (<any>this.nutrients)[key];
            }
        }
        data["apiServingKind"] = this.apiServingKind;
        return data;
    }
}

export interface IFoodItem {
    id?: string | undefined;
    name?: string | undefined;
    brandName?: string | undefined;
    fatSecretFoodId?: string | undefined;
    fatSecretServingId?: string | undefined;
    scaleFactor?: number;
    quantity?: number;
    unit?: string | undefined;
    weightGramsPerUnit?: number | undefined;
    nutrients?: { [key: string]: number; } | undefined;
    apiServingKind?: UnitKind;
}

export class GetChatMessagesRequest implements IGetChatMessagesRequest {
    loggedDateUtc!: Date;

    constructor(data?: IGetChatMessagesRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.loggedDateUtc = _data["loggedDateUtc"] ? new Date(_data["loggedDateUtc"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetChatMessagesRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetChatMessagesRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loggedDateUtc"] = this.loggedDateUtc ? this.loggedDateUtc.toISOString() : <any>undefined;
        return data;
    }
}

export interface IGetChatMessagesRequest {
    loggedDateUtc: Date;
}

export class GetChatMessagesResponse implements IGetChatMessagesResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    messages?: ChatMessage[] | undefined;

    constructor(data?: IGetChatMessagesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.correlationId = _data["correlationId"];
            this.stackTrace = _data["stackTrace"];
            this.accountId = _data["accountId"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ChatMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetChatMessagesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetChatMessagesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["correlationId"] = this.correlationId;
        data["stackTrace"] = this.stackTrace;
        data["accountId"] = this.accountId;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetChatMessagesResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    messages?: ChatMessage[] | undefined;
}

export class GetDetailedSummaryRequest implements IGetDetailedSummaryRequest {
    loggedDateUtc?: Date;

    constructor(data?: IGetDetailedSummaryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.loggedDateUtc = _data["loggedDateUtc"] ? new Date(_data["loggedDateUtc"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetDetailedSummaryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetDetailedSummaryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loggedDateUtc"] = this.loggedDateUtc ? this.loggedDateUtc.toISOString() : <any>undefined;
        return data;
    }
}

export interface IGetDetailedSummaryRequest {
    loggedDateUtc?: Date;
}

export class GetDetailedSummaryResponse implements IGetDetailedSummaryResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    nutrients?: NutrientBreakdown[] | undefined;
    foods?: FoodBreakdown[] | undefined;

    constructor(data?: IGetDetailedSummaryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.correlationId = _data["correlationId"];
            this.stackTrace = _data["stackTrace"];
            this.accountId = _data["accountId"];
            if (Array.isArray(_data["nutrients"])) {
                this.nutrients = [] as any;
                for (let item of _data["nutrients"])
                    this.nutrients!.push(NutrientBreakdown.fromJS(item));
            }
            if (Array.isArray(_data["foods"])) {
                this.foods = [] as any;
                for (let item of _data["foods"])
                    this.foods!.push(FoodBreakdown.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetDetailedSummaryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetDetailedSummaryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["correlationId"] = this.correlationId;
        data["stackTrace"] = this.stackTrace;
        data["accountId"] = this.accountId;
        if (Array.isArray(this.nutrients)) {
            data["nutrients"] = [];
            for (let item of this.nutrients)
                data["nutrients"].push(item.toJSON());
        }
        if (Array.isArray(this.foods)) {
            data["foods"] = [];
            for (let item of this.foods)
                data["foods"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetDetailedSummaryResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    nutrients?: NutrientBreakdown[] | undefined;
    foods?: FoodBreakdown[] | undefined;
}

export class GetFeedbackRequest implements IGetFeedbackRequest {
    feedbackId?: string | undefined;
    feedbackType?: string | undefined;
    includeAllAccounts?: boolean;
    isCompleted?: boolean | undefined;
    completedOnly?: boolean;
    incompleteOnly?: boolean;

    constructor(data?: IGetFeedbackRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.feedbackId = _data["feedbackId"];
            this.feedbackType = _data["feedbackType"];
            this.includeAllAccounts = _data["includeAllAccounts"];
            this.isCompleted = _data["isCompleted"];
            this.completedOnly = _data["completedOnly"];
            this.incompleteOnly = _data["incompleteOnly"];
        }
    }

    static fromJS(data: any): GetFeedbackRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetFeedbackRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["feedbackId"] = this.feedbackId;
        data["feedbackType"] = this.feedbackType;
        data["includeAllAccounts"] = this.includeAllAccounts;
        data["isCompleted"] = this.isCompleted;
        data["completedOnly"] = this.completedOnly;
        data["incompleteOnly"] = this.incompleteOnly;
        return data;
    }
}

export interface IGetFeedbackRequest {
    feedbackId?: string | undefined;
    feedbackType?: string | undefined;
    includeAllAccounts?: boolean;
    isCompleted?: boolean | undefined;
    completedOnly?: boolean;
    incompleteOnly?: boolean;
}

export class GetFeedbackResponse implements IGetFeedbackResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    feedbackEntries?: FeedbackEntry[] | undefined;
    feedbackEntry?: FeedbackEntry;

    constructor(data?: IGetFeedbackResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.correlationId = _data["correlationId"];
            this.stackTrace = _data["stackTrace"];
            this.accountId = _data["accountId"];
            if (Array.isArray(_data["feedbackEntries"])) {
                this.feedbackEntries = [] as any;
                for (let item of _data["feedbackEntries"])
                    this.feedbackEntries!.push(FeedbackEntry.fromJS(item));
            }
            this.feedbackEntry = _data["feedbackEntry"] ? FeedbackEntry.fromJS(_data["feedbackEntry"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetFeedbackResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetFeedbackResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["correlationId"] = this.correlationId;
        data["stackTrace"] = this.stackTrace;
        data["accountId"] = this.accountId;
        if (Array.isArray(this.feedbackEntries)) {
            data["feedbackEntries"] = [];
            for (let item of this.feedbackEntries)
                data["feedbackEntries"].push(item.toJSON());
        }
        data["feedbackEntry"] = this.feedbackEntry ? this.feedbackEntry.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetFeedbackResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    feedbackEntries?: FeedbackEntry[] | undefined;
    feedbackEntry?: FeedbackEntry;
}

export class GetFoodEntriesRequest implements IGetFoodEntriesRequest {
    loggedDateUtc?: Date | undefined;
    meal?: MealType;

    constructor(data?: IGetFoodEntriesRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.loggedDateUtc = _data["loggedDateUtc"] ? new Date(_data["loggedDateUtc"].toString()) : <any>undefined;
            this.meal = _data["meal"];
        }
    }

    static fromJS(data: any): GetFoodEntriesRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetFoodEntriesRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loggedDateUtc"] = this.loggedDateUtc ? this.loggedDateUtc.toISOString() : <any>undefined;
        data["meal"] = this.meal;
        return data;
    }
}

export interface IGetFoodEntriesRequest {
    loggedDateUtc?: Date | undefined;
    meal?: MealType;
}

export class GetFoodEntriesResponse implements IGetFoodEntriesResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    foodEntries?: FoodEntry[] | undefined;

    constructor(data?: IGetFoodEntriesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.correlationId = _data["correlationId"];
            this.stackTrace = _data["stackTrace"];
            this.accountId = _data["accountId"];
            if (Array.isArray(_data["foodEntries"])) {
                this.foodEntries = [] as any;
                for (let item of _data["foodEntries"])
                    this.foodEntries!.push(FoodEntry.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetFoodEntriesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetFoodEntriesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["correlationId"] = this.correlationId;
        data["stackTrace"] = this.stackTrace;
        data["accountId"] = this.accountId;
        if (Array.isArray(this.foodEntries)) {
            data["foodEntries"] = [];
            for (let item of this.foodEntries)
                data["foodEntries"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetFoodEntriesResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    foodEntries?: FoodEntry[] | undefined;
}

export class LearnMoreAboutRequest implements ILearnMoreAboutRequest {
    topic?: string | undefined;
    loggedDateUtc?: Date | undefined;

    constructor(data?: ILearnMoreAboutRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.topic = _data["topic"];
            this.loggedDateUtc = _data["loggedDateUtc"] ? new Date(_data["loggedDateUtc"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): LearnMoreAboutRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LearnMoreAboutRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["topic"] = this.topic;
        data["loggedDateUtc"] = this.loggedDateUtc ? this.loggedDateUtc.toISOString() : <any>undefined;
        return data;
    }
}

export interface ILearnMoreAboutRequest {
    topic?: string | undefined;
    loggedDateUtc?: Date | undefined;
}

export class LogMealToolResponse implements ILogMealToolResponse {
    mealName?: string | undefined;
    pendingMessageId?: string | undefined;
    loggedDateUtc?: Date;
    selectableFoodMatches?: { [key: string]: SelectableFoodMatch[]; } | undefined;

    constructor(data?: ILogMealToolResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mealName = _data["mealName"];
            this.pendingMessageId = _data["pendingMessageId"];
            this.loggedDateUtc = _data["loggedDateUtc"] ? new Date(_data["loggedDateUtc"].toString()) : <any>undefined;
            if (_data["selectableFoodMatches"]) {
                this.selectableFoodMatches = {} as any;
                for (let key in _data["selectableFoodMatches"]) {
                    if (_data["selectableFoodMatches"].hasOwnProperty(key))
                        (<any>this.selectableFoodMatches)![key] = _data["selectableFoodMatches"][key] ? _data["selectableFoodMatches"][key].map((i: any) => SelectableFoodMatch.fromJS(i)) : [];
                }
            }
        }
    }

    static fromJS(data: any): LogMealToolResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LogMealToolResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mealName"] = this.mealName;
        data["pendingMessageId"] = this.pendingMessageId;
        data["loggedDateUtc"] = this.loggedDateUtc ? this.loggedDateUtc.toISOString() : <any>undefined;
        if (this.selectableFoodMatches) {
            data["selectableFoodMatches"] = {};
            for (let key in this.selectableFoodMatches) {
                if (this.selectableFoodMatches.hasOwnProperty(key))
                    (<any>data["selectableFoodMatches"])[key] = (<any>this.selectableFoodMatches)[key];
            }
        }
        return data;
    }
}

export interface ILogMealToolResponse {
    mealName?: string | undefined;
    pendingMessageId?: string | undefined;
    loggedDateUtc?: Date;
    selectableFoodMatches?: { [key: string]: SelectableFoodMatch[]; } | undefined;
}

export enum MealType {
    Unknown = "Unknown",
    Breakfast = "Breakfast",
    Lunch = "Lunch",
    Dinner = "Dinner",
    Snack = "Snack",
}

export enum MessageRoleTypes {
    User = "User",
    Assistant = "Assistant",
    Tool = "Tool",
    System = "System",
    ContextNote = "ContextNote",
    PendingFoodSelection = "PendingFoodSelection",
    CompletedFoodSelection = "CompletedFoodSelection",
}

export class NutrientBreakdown implements INutrientBreakdown {
    nutrientKey?: string | undefined;
    nutrientName?: string | undefined;
    unit?: string | undefined;
    totalAmount?: number;
    minTarget?: number | undefined;
    maxTarget?: number | undefined;
    valueType?: string | undefined;
    source?: string | undefined;
    sortOrder?: number;
    readonly percentOfTarget?: number | undefined;
    foods?: FoodContribution[] | undefined;

    constructor(data?: INutrientBreakdown) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nutrientKey = _data["nutrientKey"];
            this.nutrientName = _data["nutrientName"];
            this.unit = _data["unit"];
            this.totalAmount = _data["totalAmount"];
            this.minTarget = _data["minTarget"];
            this.maxTarget = _data["maxTarget"];
            this.valueType = _data["valueType"];
            this.source = _data["source"];
            this.sortOrder = _data["sortOrder"];
            (<any>this).percentOfTarget = _data["percentOfTarget"];
            if (Array.isArray(_data["foods"])) {
                this.foods = [] as any;
                for (let item of _data["foods"])
                    this.foods!.push(FoodContribution.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NutrientBreakdown {
        data = typeof data === 'object' ? data : {};
        let result = new NutrientBreakdown();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nutrientKey"] = this.nutrientKey;
        data["nutrientName"] = this.nutrientName;
        data["unit"] = this.unit;
        data["totalAmount"] = this.totalAmount;
        data["minTarget"] = this.minTarget;
        data["maxTarget"] = this.maxTarget;
        data["valueType"] = this.valueType;
        data["source"] = this.source;
        data["sortOrder"] = this.sortOrder;
        data["percentOfTarget"] = this.percentOfTarget;
        if (Array.isArray(this.foods)) {
            data["foods"] = [];
            for (let item of this.foods)
                data["foods"].push(item.toJSON());
        }
        return data;
    }
}

export interface INutrientBreakdown {
    nutrientKey?: string | undefined;
    nutrientName?: string | undefined;
    unit?: string | undefined;
    totalAmount?: number;
    minTarget?: number | undefined;
    maxTarget?: number | undefined;
    valueType?: string | undefined;
    source?: string | undefined;
    sortOrder?: number;
    percentOfTarget?: number | undefined;
    foods?: FoodContribution[] | undefined;
}

export class NutrientContribution implements INutrientContribution {
    nutrientKey?: string | undefined;
    nutrientName?: string | undefined;
    name?: string | undefined;
    brandName?: string | undefined;
    amount?: number;
    unit?: string | undefined;
    originalUnit?: string | undefined;

    constructor(data?: INutrientContribution) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nutrientKey = _data["nutrientKey"];
            this.nutrientName = _data["nutrientName"];
            this.name = _data["name"];
            this.brandName = _data["brandName"];
            this.amount = _data["amount"];
            this.unit = _data["unit"];
            this.originalUnit = _data["originalUnit"];
        }
    }

    static fromJS(data: any): NutrientContribution {
        data = typeof data === 'object' ? data : {};
        let result = new NutrientContribution();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nutrientKey"] = this.nutrientKey;
        data["nutrientName"] = this.nutrientName;
        data["name"] = this.name;
        data["brandName"] = this.brandName;
        data["amount"] = this.amount;
        data["unit"] = this.unit;
        data["originalUnit"] = this.originalUnit;
        return data;
    }
}

export interface INutrientContribution {
    nutrientKey?: string | undefined;
    nutrientName?: string | undefined;
    name?: string | undefined;
    brandName?: string | undefined;
    amount?: number;
    unit?: string | undefined;
    originalUnit?: string | undefined;
}

export class Request implements IRequest {

    constructor(data?: IRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): Request {
        data = typeof data === 'object' ? data : {};
        let result = new Request();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IRequest {
}

export class RunChatRequest implements IRunChatRequest {
    message?: string | undefined;
    loggedDateUtc?: Date | undefined;

    constructor(data?: IRunChatRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.loggedDateUtc = _data["loggedDateUtc"] ? new Date(_data["loggedDateUtc"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RunChatRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RunChatRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["loggedDateUtc"] = this.loggedDateUtc ? this.loggedDateUtc.toISOString() : <any>undefined;
        return data;
    }
}

export interface IRunChatRequest {
    message?: string | undefined;
    loggedDateUtc?: Date | undefined;
}

export class SelectableFoodMatch implements ISelectableFoodMatch {
    fatSecretFoodId?: string | undefined;
    displayName?: string | undefined;
    brandName?: string | undefined;
    originalText?: string | undefined;
    rank?: number;
    selectedServingId?: string | undefined;
    totalGrams?: number;
    servings?: SelectableFoodServing[] | undefined;

    constructor(data?: ISelectableFoodMatch) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fatSecretFoodId = _data["fatSecretFoodId"];
            this.displayName = _data["displayName"];
            this.brandName = _data["brandName"];
            this.originalText = _data["originalText"];
            this.rank = _data["rank"];
            this.selectedServingId = _data["selectedServingId"];
            this.totalGrams = _data["totalGrams"];
            if (Array.isArray(_data["servings"])) {
                this.servings = [] as any;
                for (let item of _data["servings"])
                    this.servings!.push(SelectableFoodServing.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SelectableFoodMatch {
        data = typeof data === 'object' ? data : {};
        let result = new SelectableFoodMatch();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fatSecretFoodId"] = this.fatSecretFoodId;
        data["displayName"] = this.displayName;
        data["brandName"] = this.brandName;
        data["originalText"] = this.originalText;
        data["rank"] = this.rank;
        data["selectedServingId"] = this.selectedServingId;
        data["totalGrams"] = this.totalGrams;
        if (Array.isArray(this.servings)) {
            data["servings"] = [];
            for (let item of this.servings)
                data["servings"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISelectableFoodMatch {
    fatSecretFoodId?: string | undefined;
    displayName?: string | undefined;
    brandName?: string | undefined;
    originalText?: string | undefined;
    rank?: number;
    selectedServingId?: string | undefined;
    totalGrams?: number;
    servings?: SelectableFoodServing[] | undefined;
}

export class SelectableFoodServing implements ISelectableFoodServing {
    fatSecretServingId?: string | undefined;
    description?: string | undefined;
    displayQuantity?: number;
    displayUnit?: string | undefined;
    scaledQuantity?: number;
    scaledUnit?: string | undefined;
    weightGramsPerUnit?: number | undefined;
    nutrients?: { [key: string]: number; } | undefined;
    apiServingKind?: UnitKind;
    isBestMatch?: boolean;

    constructor(data?: ISelectableFoodServing) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fatSecretServingId = _data["fatSecretServingId"];
            this.description = _data["description"];
            this.displayQuantity = _data["displayQuantity"];
            this.displayUnit = _data["displayUnit"];
            this.scaledQuantity = _data["scaledQuantity"];
            this.scaledUnit = _data["scaledUnit"];
            this.weightGramsPerUnit = _data["weightGramsPerUnit"];
            if (_data["nutrients"]) {
                this.nutrients = {} as any;
                for (let key in _data["nutrients"]) {
                    if (_data["nutrients"].hasOwnProperty(key))
                        (<any>this.nutrients)![key] = _data["nutrients"][key];
                }
            }
            this.apiServingKind = _data["apiServingKind"];
            this.isBestMatch = _data["isBestMatch"];
        }
    }

    static fromJS(data: any): SelectableFoodServing {
        data = typeof data === 'object' ? data : {};
        let result = new SelectableFoodServing();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fatSecretServingId"] = this.fatSecretServingId;
        data["description"] = this.description;
        data["displayQuantity"] = this.displayQuantity;
        data["displayUnit"] = this.displayUnit;
        data["scaledQuantity"] = this.scaledQuantity;
        data["scaledUnit"] = this.scaledUnit;
        data["weightGramsPerUnit"] = this.weightGramsPerUnit;
        if (this.nutrients) {
            data["nutrients"] = {};
            for (let key in this.nutrients) {
                if (this.nutrients.hasOwnProperty(key))
                    (<any>data["nutrients"])[key] = (<any>this.nutrients)[key];
            }
        }
        data["apiServingKind"] = this.apiServingKind;
        data["isBestMatch"] = this.isBestMatch;
        return data;
    }
}

export interface ISelectableFoodServing {
    fatSecretServingId?: string | undefined;
    description?: string | undefined;
    displayQuantity?: number;
    displayUnit?: string | undefined;
    scaledQuantity?: number;
    scaledUnit?: string | undefined;
    weightGramsPerUnit?: number | undefined;
    nutrients?: { [key: string]: number; } | undefined;
    apiServingKind?: UnitKind;
    isBestMatch?: boolean;
}

export class SubmitServingSelectionRequest implements ISubmitServingSelectionRequest {
    loggedDateUtc?: Date;
    pendingMessageId?: string | undefined;
    selections?: UserSelectedServing[] | undefined;

    constructor(data?: ISubmitServingSelectionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.loggedDateUtc = _data["loggedDateUtc"] ? new Date(_data["loggedDateUtc"].toString()) : <any>undefined;
            this.pendingMessageId = _data["pendingMessageId"];
            if (Array.isArray(_data["selections"])) {
                this.selections = [] as any;
                for (let item of _data["selections"])
                    this.selections!.push(UserSelectedServing.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SubmitServingSelectionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitServingSelectionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loggedDateUtc"] = this.loggedDateUtc ? this.loggedDateUtc.toISOString() : <any>undefined;
        data["pendingMessageId"] = this.pendingMessageId;
        if (Array.isArray(this.selections)) {
            data["selections"] = [];
            for (let item of this.selections)
                data["selections"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISubmitServingSelectionRequest {
    loggedDateUtc?: Date;
    pendingMessageId?: string | undefined;
    selections?: UserSelectedServing[] | undefined;
}

export class SubmitServingSelectionResponse implements ISubmitServingSelectionResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    foodEntryId?: string | undefined;
    updatedSelectionMessage?: ChatMessage;
    newAssistantMessage?: ChatMessage;

    constructor(data?: ISubmitServingSelectionResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.correlationId = _data["correlationId"];
            this.stackTrace = _data["stackTrace"];
            this.accountId = _data["accountId"];
            this.foodEntryId = _data["foodEntryId"];
            this.updatedSelectionMessage = _data["updatedSelectionMessage"] ? ChatMessage.fromJS(_data["updatedSelectionMessage"]) : <any>undefined;
            this.newAssistantMessage = _data["newAssistantMessage"] ? ChatMessage.fromJS(_data["newAssistantMessage"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SubmitServingSelectionResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitServingSelectionResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["correlationId"] = this.correlationId;
        data["stackTrace"] = this.stackTrace;
        data["accountId"] = this.accountId;
        data["foodEntryId"] = this.foodEntryId;
        data["updatedSelectionMessage"] = this.updatedSelectionMessage ? this.updatedSelectionMessage.toJSON() : <any>undefined;
        data["newAssistantMessage"] = this.newAssistantMessage ? this.newAssistantMessage.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISubmitServingSelectionResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    foodEntryId?: string | undefined;
    updatedSelectionMessage?: ChatMessage;
    newAssistantMessage?: ChatMessage;
}

export class SubmitUserFeedbackRequest implements ISubmitUserFeedbackRequest {
    feedbackType?: string | undefined;
    message?: string | undefined;
    context?: string | undefined;

    constructor(data?: ISubmitUserFeedbackRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.feedbackType = _data["feedbackType"];
            this.message = _data["message"];
            this.context = _data["context"];
        }
    }

    static fromJS(data: any): SubmitUserFeedbackRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitUserFeedbackRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["feedbackType"] = this.feedbackType;
        data["message"] = this.message;
        data["context"] = this.context;
        return data;
    }
}

export interface ISubmitUserFeedbackRequest {
    feedbackType?: string | undefined;
    message?: string | undefined;
    context?: string | undefined;
}

export class SubmitUserFeedbackResponse implements ISubmitUserFeedbackResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    feedbackEntry?: FeedbackEntry;

    constructor(data?: ISubmitUserFeedbackResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.correlationId = _data["correlationId"];
            this.stackTrace = _data["stackTrace"];
            this.accountId = _data["accountId"];
            this.feedbackEntry = _data["feedbackEntry"] ? FeedbackEntry.fromJS(_data["feedbackEntry"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SubmitUserFeedbackResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitUserFeedbackResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["correlationId"] = this.correlationId;
        data["stackTrace"] = this.stackTrace;
        data["accountId"] = this.accountId;
        data["feedbackEntry"] = this.feedbackEntry ? this.feedbackEntry.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISubmitUserFeedbackResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    feedbackEntry?: FeedbackEntry;
}

export class TokenUsage implements ITokenUsage {
    promptTokens?: number | undefined;
    completionTokens?: number | undefined;
    totalTokens?: number | undefined;

    constructor(data?: ITokenUsage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.promptTokens = _data["promptTokens"];
            this.completionTokens = _data["completionTokens"];
            this.totalTokens = _data["totalTokens"];
        }
    }

    static fromJS(data: any): TokenUsage {
        data = typeof data === 'object' ? data : {};
        let result = new TokenUsage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["promptTokens"] = this.promptTokens;
        data["completionTokens"] = this.completionTokens;
        data["totalTokens"] = this.totalTokens;
        return data;
    }
}

export interface ITokenUsage {
    promptTokens?: number | undefined;
    completionTokens?: number | undefined;
    totalTokens?: number | undefined;
}

export enum UnitKind {
    Weight = "Weight",
    Volume = "Volume",
    Count = "Count",
}

export class UpdateFeedbackRequest implements IUpdateFeedbackRequest {
    feedbackId?: string | undefined;
    feedbackType?: string | undefined;
    message?: string | undefined;
    context?: string | undefined;

    constructor(data?: IUpdateFeedbackRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.feedbackId = _data["feedbackId"];
            this.feedbackType = _data["feedbackType"];
            this.message = _data["message"];
            this.context = _data["context"];
        }
    }

    static fromJS(data: any): UpdateFeedbackRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFeedbackRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["feedbackId"] = this.feedbackId;
        data["feedbackType"] = this.feedbackType;
        data["message"] = this.message;
        data["context"] = this.context;
        return data;
    }
}

export interface IUpdateFeedbackRequest {
    feedbackId?: string | undefined;
    feedbackType?: string | undefined;
    message?: string | undefined;
    context?: string | undefined;
}

export class UpdateFeedbackResponse implements IUpdateFeedbackResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    feedbackEntry?: FeedbackEntry;

    constructor(data?: IUpdateFeedbackResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.correlationId = _data["correlationId"];
            this.stackTrace = _data["stackTrace"];
            this.accountId = _data["accountId"];
            this.feedbackEntry = _data["feedbackEntry"] ? FeedbackEntry.fromJS(_data["feedbackEntry"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateFeedbackResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFeedbackResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["correlationId"] = this.correlationId;
        data["stackTrace"] = this.stackTrace;
        data["accountId"] = this.accountId;
        data["feedbackEntry"] = this.feedbackEntry ? this.feedbackEntry.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUpdateFeedbackResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    feedbackEntry?: FeedbackEntry;
}

export class UpdateFoodEntryRequest implements IUpdateFoodEntryRequest {
    foodEntryId?: string | undefined;
    description?: string | undefined;
    meal?: MealType;
    loggedDateUtc?: Date | undefined;
    parsedItems?: FoodItem[] | undefined;

    constructor(data?: IUpdateFoodEntryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.foodEntryId = _data["foodEntryId"];
            this.description = _data["description"];
            this.meal = _data["meal"];
            this.loggedDateUtc = _data["loggedDateUtc"] ? new Date(_data["loggedDateUtc"].toString()) : <any>undefined;
            if (Array.isArray(_data["parsedItems"])) {
                this.parsedItems = [] as any;
                for (let item of _data["parsedItems"])
                    this.parsedItems!.push(FoodItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateFoodEntryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFoodEntryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["foodEntryId"] = this.foodEntryId;
        data["description"] = this.description;
        data["meal"] = this.meal;
        data["loggedDateUtc"] = this.loggedDateUtc ? this.loggedDateUtc.toISOString() : <any>undefined;
        if (Array.isArray(this.parsedItems)) {
            data["parsedItems"] = [];
            for (let item of this.parsedItems)
                data["parsedItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateFoodEntryRequest {
    foodEntryId?: string | undefined;
    description?: string | undefined;
    meal?: MealType;
    loggedDateUtc?: Date | undefined;
    parsedItems?: FoodItem[] | undefined;
}

export class UpdateFoodEntryResponse implements IUpdateFoodEntryResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    updatedEntry?: FoodEntry;

    constructor(data?: IUpdateFoodEntryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.isSuccess = _data["isSuccess"];
            this.correlationId = _data["correlationId"];
            this.stackTrace = _data["stackTrace"];
            this.accountId = _data["accountId"];
            this.updatedEntry = _data["updatedEntry"] ? FoodEntry.fromJS(_data["updatedEntry"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateFoodEntryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFoodEntryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["isSuccess"] = this.isSuccess;
        data["correlationId"] = this.correlationId;
        data["stackTrace"] = this.stackTrace;
        data["accountId"] = this.accountId;
        data["updatedEntry"] = this.updatedEntry ? this.updatedEntry.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUpdateFoodEntryResponse {
    errors?: ErrorDto[] | undefined;
    isSuccess?: boolean;
    correlationId?: string | undefined;
    stackTrace?: string | undefined;
    accountId?: string | undefined;
    updatedEntry?: FoodEntry;
}

export class UserSelectedServing implements IUserSelectedServing {
    originalText?: string | undefined;
    fatSecretFoodId?: string | undefined;
    fatSecretServingId?: string | undefined;
    editedQuantity?: number | undefined;

    constructor(data?: IUserSelectedServing) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.originalText = _data["originalText"];
            this.fatSecretFoodId = _data["fatSecretFoodId"];
            this.fatSecretServingId = _data["fatSecretServingId"];
            this.editedQuantity = _data["editedQuantity"];
        }
    }

    static fromJS(data: any): UserSelectedServing {
        data = typeof data === 'object' ? data : {};
        let result = new UserSelectedServing();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["originalText"] = this.originalText;
        data["fatSecretFoodId"] = this.fatSecretFoodId;
        data["fatSecretServingId"] = this.fatSecretServingId;
        data["editedQuantity"] = this.editedQuantity;
        return data;
    }
}

export interface IUserSelectedServing {
    originalText?: string | undefined;
    fatSecretFoodId?: string | undefined;
    fatSecretServingId?: string | undefined;
    editedQuantity?: number | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}