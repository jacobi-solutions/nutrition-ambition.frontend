#!/usr/bin/env node

/**
 * write-version.js
 * --------------------------------------
 * Automatically generates version info tied to git commits.
 * Runs on every commit via Husky pre-commit hook.
 *
 * - Uses SemVer format from package.json
 * - Adds commit count as build number
 * - Branch-aware versioning
 * - Skips rewrite if unchanged
 */

const { execSync } = require("child_process");
const fs = require("fs");
const path = require("path");

const versionFile = path.join(__dirname, "../src/environments/version.ts");
const packageJsonFile = path.join(__dirname, "../package.json");

function getAndBumpPackageVersion() {
  try {
    const packageJson = JSON.parse(fs.readFileSync(packageJsonFile, "utf8"));
    const currentVersion = packageJson.version;
    
    // Parse current version (e.g., "0.1.5" -> [0, 1, 5])
    const versionParts = currentVersion.split('.').map(num => parseInt(num, 10));
    if (versionParts.length !== 3) {
      throw new Error(`Invalid version format: ${currentVersion}`);
    }
    
    // Auto-increment patch version (3rd number)
    versionParts[2] += 1;
    const newVersion = versionParts.join('.');
    
    // Update package.json with new version
    packageJson.version = newVersion;
    fs.writeFileSync(packageJsonFile, JSON.stringify(packageJson, null, 2) + '\n', 'utf8');
    
    console.log(`📦 Auto-bumped package.json: ${currentVersion} → ${newVersion}`);
    return newVersion;
  } catch (err) {
    console.error("⚠️  Unable to read/update package.json version:", err.message);
    return "0.0.1"; // fallback
  }
}

function getGitInfo() {
  try {
    const hash = execSync("git rev-parse --short HEAD").toString().trim();
    const branch = execSync("git rev-parse --abbrev-ref HEAD").toString().trim();
    
    // Get commit count as build number (more meaningful than timestamp)
    const commitCount = execSync("git rev-list --count HEAD").toString().trim();

    return { hash, branch, commitCount };
  } catch (err) {
    console.error("⚠️  Unable to read git info. Are you in a git repo?");
    process.exit(1);
  }
}

function buildVersion(packageVersion, { hash, commitCount, branch }) {
  // Use SemVer format: MAJOR.MINOR.PATCH+BUILD
  // Examples:
  // - Production: "1.2.3"
  // - Development: "1.2.3-dev.45+a1b2c3"
  // - Feature branch: "1.2.3-feature.45+a1b2c3"
  
  if (branch === "main" || branch === "master") {
    // Production builds: just use package.json version
    return packageVersion;
  } else {
    // Development/feature builds: add build metadata
    const branchSuffix = branch === "develop" ? "dev" : branch.replace(/[^a-zA-Z0-9]/g, "");
    return `${packageVersion}-${branchSuffix}.${commitCount}+${hash}`;
  }
}

function writeVersionFile(version, gitInfo) {
  const banner = `// AUTO-GENERATED FILE. DO NOT EDIT.
// This file was generated by tools/write-version.js
// Commit: ${gitInfo.hash}, Branch: ${gitInfo.branch}, Build: ${gitInfo.commitCount}

export const APP_VERSION = "${version}";
export const COMMIT_HASH = "${gitInfo.hash}";
`;

  // Skip write if identical
  if (fs.existsSync(versionFile)) {
    const current = fs.readFileSync(versionFile, "utf8");
    if (current === banner) {
      console.log(`ℹ️  Version unchanged (${version}), skipping write.`);
      return;
    }
  }

  fs.writeFileSync(versionFile, banner, { encoding: "utf8" });
  console.log(`✅ Version updated -> ${version} (commit: ${gitInfo.hash})`);
}

(function main() {
  const packageVersion = getAndBumpPackageVersion();
  const gitInfo = getGitInfo();
  const version = buildVersion(packageVersion, gitInfo);
  writeVersionFile(version, gitInfo);
})();
